<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-5" />
	<meta name="Author" content="Elitsa Nikolova" />
	<meta name="Robots" content="index,follow" />
	<meta name="Description" content="Synthesis and Analysis of Algorithms" />
	<meta name="Keywords" content="Synthesis,Analysis,Algorithms" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<title>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</title>
    <style type="text/css">
<!--
.style1 {
	font-size: 1.2em;
	color: #333333;
}
.style7 {font-size: 1.2em}
.style13 {font-size: 0.7em}
-->
    </style>
</head>
<body>
	<div id="main">

<ul id="menu">
<li><a href="sort.html"><span class="key">Алгоритми за сортиране</span></a></li>
            <li><a href="metods.html"><span class="key">Методи за създаване</span></a></li>
            <li><a href="struct.html"><span class="key">Структури данни</span></a></li>
            <li><a href="index.html"><span class="key">Алгоритми</a></li>
</ul>
		
  <div id="intro_left">
			<p>Алгоритмите в сайта са описани на псевдокод, което ги прави по-лесни за четене и разбиране.</p>
	  </div>
		
		<div id="intro_right">
			<p class="white">УЕБ БАЗИРАНО ПРИЛОЖЕНИЕ ПО</p>
		  <h1>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</h1>
			<p></p>
		</div>

  <ul id="menu_left">
			<li><a href="sort quick.html"><span>Бързо сортиране</span></a></li>
			<li><a href="sort merge.html"><span>Сортиране чрез сливане</span></a></li>
			<li><a href="sort  pyramid.html"><span>Сортиране чрез дърво. Пирамидално сортиране</span></a></li>
            <li><a href="sort no comparison.html"><span>Сортировка без сравнения</span></a></li>
		<li><a href="task04.html"><span>Задачи</span></a></li>
	  </ul>

			<div class="special">
			  <h1>Бързо сортиране 
			  </h1>
			  <p>Идеята  на бързото сортиране може да се разглежда като развитие на идеята за сортиране  по метода на мехурчето, но вместо отстраняване на инверсия между съседни  елементи, такава се отстранява между елементи, които се намират на известно  разстояние един от друг. От друга страна, този метод прилага рационално подхода  разделяй и владей. <br />
			    Нека  ava2,...,an е  редица от елементи, които подлежат на сортиране. Чрез поредица от сравнения (и  размествания) с общ брой, пропорционален на п,  разделяме редицата на две съпоставими по дължина части, които  са взаимно подредени. Смисълът на това е, че  всеки елемент на първата част е по-малък (или равен) от кой да е елемент на  втората част. След това към всяка от двете части постъпваме по същия начин:  чрез сравнения и размествания я разделяме на по две взаимно подредени части и  т.н., докато достигнем до взаимно подредени части от по един елемент - тогава  редицата е сортирана. <br />
			    Нека  приемем, че разделянето на част от редицата от елемента а( до  елемента а,, на две взаимно  подредени подредици се осъществява от процедурата partition(a,l,r,i). Тук i е номерът на елемента в средата на разделената редица. Тогава  описанието на целия алгоритъм за бързо сортиране ще бъде: <br />
			    </p>
			  <p>алгоритъм Quicksort(a,l,r); <br />
			    ако l&lt;r то <br />
			    partition(a, l, r, i); <br />
			    quicksort(a, l, i-1); <br />
			    quicksort(a, i+l,r); </p>
			  <p><br />
			    Нека  приемем още, че разделянето с partition на две  взаимно подредени заети с равни по брой елементи се осъществява с п  сравнения. Тогава оценката за сложност на описания алгоритъм се дава от  следната рекурентна формула<br />
                <em>f</em><em>(</em><em>n</em><em>)  = </em><em>cn</em><em>+2f </em><img src="images/sort quick_image002.gif" alt="quickSort" width="23" height="29" /><br />
                Развитието на тази  формула до затворен вид (до <em>f</em>(1))  води към <br />
                <em>f</em><em>(</em><em>n</em><em>) </em>= кСп = Сп log2  п =O(п log  п) <br />
                Ключов  момент в тази оценка е разделянето с partition на две  равни по дължина части, т.е. в прилагането на подхода "разделяй и владей". Ако  разделянето се "изроди" в две части, едната от които е с дължина единица, а  другата с дължина n-1, то  оценката ще се върне към O(п2).  Наистина, <br />
                <em>f</em><em>(</em><em>n</em><em>) </em><em>= </em>Сn+f(n<em>-1) = С</em><em>n</em><em> + С(</em><em>n</em><em> -1) +...+</em><em>f</em><em>(1) = </em>O(п2)<br />
                Сега  остава да намерим подходяща форма за реализация на процедурата partition. Именно  тук се проявява идеята за сравнение и отстраняване на инверсия между елементи, които  отстоят на известно разстояние един от друг в редицата. Съществен момент в  реализацията на partition е  определянето на ключов елемент р  измежду елементите, подлежащи на разделяне от а, до аг. Този  елемент трябва да е среден по стойност, в смисъл че трябва да има приблизително  равен брой по- големи и съответно по-малки от него елементи в редицата за  разделяне. Така след разделянето той трябва да се окаже в средата на тази  редица. Изборът на такъв елемент (медиана на  елементите в редицата за разделяне) сам по себе си е сложна работа, в смисъл че  точното му определяне изисква сортиране на редицата. Следователно ще прибегнем  до случаен избор на такъв елемент и нека това да е първият елемент на редицата -  а,. От това, че такъв избор може и да не е най- подходящият, ще  зависи и отклонението от направената по-горе оценка за сложност. <br />
                Въвеждаме два указателя i и j следящи  елементите съответно от левия и десния край на редицата. Тъй като ключовият  елемент се намира в левия край, започваме сравнението между него и елементите  от десния край. Елементите от десния край трябва да са по-големи от ключовия;  ако това е така, придвижваме десния указател j наляво до достигане на инверсия p&gt;=j. Инверсията  се отстранява като ключовият елемент и Oj си разменят местата. Сега сравнението на ключовия елемент продължава с елементите от левия край,  сочени от указателя , които трябва да са по-малки от него. При среща на  инверсия става размяна на ключовия  елемент със съответния отляво и всичко продължава отначало. Този процес  продължава до изравняване на двата указателя i = j;  тогава това е окончателното място на ключовия елемент.Следва  описанието на алгоритъма <em> partition:</em><br clear="all" />
              </p>
			  <div>
                <p><em>алгоритъм  partition(A,lr, i); </em><br />
                    <em>i:=l; j:=r; p:=A[</em><em>l]; </em><br />
                    <em><u>повтаряй</u></em><br />
                    <em><u>докато</u> А[j]&gt;р <u>прави</u> j: =j-l; </em><br />
                    <em><u>ако</u> i&lt;j <u>то</u></em><br />
                    <em>А</em><em>[i]:=А[j]; А</em><em>[j]=</em><em>p; i:=i+l; </em><br />
                    <em><u>докато</u> A[i]&lt;p <u>прави</u> i:=i+l; </em><br />
                    <em><u>ако</u> i&lt;j <u>то</u></em><br />
                    <em>А[j]:=А</em><em>[i]; A[i</em><em>]:=p;j:=j-l; </em><br />
                    <em><u>докато</u> i&gt;=j; </em></p>
                <p><br />
                Оценката за сложност на  алгоритъма за бързо сортиране зависи от това, алгоритъмът <em>partition </em>да  реализира разделянето на редица с брой сравнения от >щъка на <em>п . </em>В  горния алгоритъм това наистина е така, защото сравнения се вят при всяка стъпка  на изменението на единия или другия указател. Те общо минават път&quot;,  единият с движение наляво, а другият с движение надясно, до щата им, с дължина,  равна на броя елементи в редицата за разделяне.</p>
			  </div>
              <h1>&nbsp;</h1>
			  <h1 align="center">&nbsp;</h1>
	  </div>
	   <a style="display:scroll;position:fixed;bottom:10px;right:10px;" href="#" title="В началото"><img width="30" height="30" src="images/button.png"/></a>  
</div>
	
<div id="footer">
			<p>&copy; Copyright Synthesis and Analysis of Algorithms &middot; 2017 &middot; Design: Elitsa Nikolova&middot; 
			 
			  <a href="index.html"><span>Алгоритми</span></a>&middot;
              <a href="struct.html"><span>Структури данни</span></a>&middot;
               <a href="metods.html"><span>Методи за създаване</span></a>&middot;
               <a href="sort.html"><span>Алгоритми за сортиране</span></a>&middot;
		    <a href="map.html"><span>Карта на сайта</span></a></p>
</div>
</html>