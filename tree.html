<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-5" />
	<meta name="Author" content="Elitsa Nikolova" />
	<meta name="Robots" content="index,follow" />
	<meta name="Description" content="Synthesis and Analysis of Algorithms" />
	<meta name="Keywords" content="Synthesis,Analysis,Algorithms" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<title>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</title>
    <style type="text/css">
<!--
.style1 {
	font-size: 1.2em;
	color: #333333;
}
.style7 {font-size: 1.2em}
.style13 {font-size: 0.7em}
-->
    </style>
</head>
<body>
	<div id="main">
<ul id="menu">
<li><a href="sort.html"><span class="key">Алгоритми за сортиране</span></a></li>
            <li><a href="metods.html"><span class="key">Методи за създаване</span></a></li>
            <li><a href="struct.html"><span class="key">Структури данни</span></a></li>
            <li><a href="index.html"><span class="key">Алгоритми</a></li>
</ul>
		
  <div id="intro_left">
			<p>Алгоритмите в сайта са описани на псевдокод, което ги прави по-лесни за четене и разбиране.</p>
	  </div>
		
		<div id="intro_right">
			<p class="white">УЕБ БАЗИРАНО ПРИЛОЖЕНИЕ ПО</p>
			<h1>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</h1>
			<p></p>
		</div>

	 <ul id="menu_left">
			<li><a href="steak.html"><span>Стек</span></a></li>
		<li><span><a href="tail.html">Опашка</a></span></li>
		<li><a href="list.html"><span>Списък</span></a></li>
        <li><span><a href="tree.html">Дърво</a></span></li>
		<li><span><a href="task02.html">Задачи</a></span></li>
	  </ul>

			<div class="special">
			  <h1>Структура от данни дърво </h1>
			  <p>Досега  разглежданите структури: стек, опашка, линеен списък, бяха линейни. Това, което  ги характеризира е: всеки елемент (без първия и последния) има точно един  предходник и точно един наследник. Поради това те могат да се изобразят в една  линейна последователност. Съществуват структури, елементите на които не могат  да се подредят така: могат да имат повече от един предходници или повече от  един наследници. <br />
			    Една  такава структура с много приложения, с която адекватно се представят обекти с  йерархия, е структурата <em>дърво. </em>Тя е подходяща както за представяне на  данни с присъща йерархична структура, така и за създаване на ефективни  алгоритми за данни, които сами по себе си нямат такава структура. <br />
  <em>Дърво </em>се нарича непразна двойка  множества <em>(V,R), </em>където <em>V </em>е множество на възли (върхове,  елементи), а <em>R </em>е множество на ребра. <em>Възел </em>(елемент) е прост  обект, който може да има <em>име (ключ) </em>и свързана с него информация. <em>Ребро </em>е насочена отсечка, свързваща два възела. Възел, от който излиза ребро, се нарича <em>родител (nредходник) </em>на възела,  в който влиза реброто. Възелът, в който влиз реброто, се нарича <em>наследник </em>на  възела, от който излиза реброто. Един възел НЯМI  родител и той се нарича <em>корен </em>на дървото. Възлите, които нямат  наследници, ~ наричат <em>листа </em>или <em>терминални символи. </em>Път в дървото  се нарича последователност от възли, свързани с ребра. Дефиниционно свойство на  дървото е: <em>съществува точно един път </em>от корена до кой да е възел в  дървото. Ако i структурата съществува повече от един такъв път или не  съществува път между корена и някой  възел, то тя не е дърво (а граф). <br />
			    В дървото всеки елемент (без корена) има точно <em>един </em>предходник,  а може да има повече от един наследник.  Тогава всеки възел е корен на <em>поддърво, </em>което започва от него и включва  възлите след него. Така може да се даде и следната рекурсивна дефиниция на  дърво: <br />
  &lt;дърво&gt;:  :=&lt;празно&gt; I &lt;възел с наследници  дървета&gt; <br />
  <em>Ниво </em>на даден  възел е броят на възлите от корена до него. Така възлите в едно дърво могат да  се разделят на нива <br />
  <img src="images/tree_image002.gif" alt="img2" width="230" height="127" /> </p>
			  <p><u>Представяне  на дърво </u><br />
			    Тъй като дървото не е линейна структура, компактното му  представяне (когато отделните му елементи се намират в съседни области от  паметта) не е подходящо. Още повече, понеже дървото е динамична структура, Т.е.  могат да се включват или изключват  елементи, то верижното представяне става наложително. <br />
  <img src="images/tree_image004.gif" alt="4" width="238" height="172" /> </p>
			  <p>Една  възможност за верижно представяне е да разгледаме един елемент като запис, състоящ се от поле (полета) за собствена  информация и полета за указатели към наследници. <br />
			    С поддържане на дърво се свързват  обичайните операции за динамичи структури: инициализация на празно дърво, обход  на текущото състояние и: дървото,  включване и изключване на елемент. Начинът на извършването им обач зависи от конкретната задача, която  налага използване на дървовидна структура Така например операцията включване  изисква да се определи на кого стая наследник  новият елемент, а изключване на елемент може да означава различи неща: например  изключване на цялото поддърво, започващо от елемента, или пъ! само на елемента. В последния случай трябва да е ясно какво става с наследниция на изключвания елемент. Както  беше отбелязано, тези неща се определят от конкретната задача.<br />
			    За да  разгледаме такава конкретна задача, нека преди това разгледаме еди: пос. често използвана специфична  дървовидна структура, а именно: <br />
  <u>Двоично  дърво </u><br />
			    Двоично  дърво е това, в което всеки елемент може да има най-много два наследника. <br />
  <em>Височина  (дълбочина) </em>на  дървото се нарича максималното ниво на елемент:  дървото. <br />
			    Лема 1. Максималният брой възли  от ниво <em>i </em>в  двоично дърво е 2i-1  . <br />
			    Лема 2.  Максималният брой възли в дърво с височина <em>k </em>е <em>2k </em>-1. <br />
			    Наистина,  максималният общ брой елементи в дърво с височина <em>k </em>е сумата от  максималния брой възли на всяко ниво от 1 до <em>k: </em><br />
			    20  +21 +22 + ... +2k-1 = 2k-1 <br />
			    Дефиниция.  Двоично дърво с височина <em>k, </em>което има всичките си 2k-1елемента се нарича <em>пълно </em>(ful1) <br />
			    Елегантен  начин за <em>линейно </em>представяне на нелинейната структура <em>пълно двоично  дърво </em>е, ако формално номерираме елементите <em>ниво по ниво отляво надясно: </em><br />
			    Например, следното дърво има  дълбочина 3 и 23 -1 = 7  елемента. <br />
  <img src="images/tree_image006.jpg" alt="6" width="176" height="110" />&nbsp;<br clear="all" />
              </p>
			  <p>Правилата за  линеаризиране, Т.е. подреждане на елементите в една  линейна последователност <em>А1,А2, ... , Ап, </em>се  дават от: <br />
                Лема 3. Пълно двоично дърво с <em>п </em>възела се представя в линейна  последователност като за всяко <em>i</em>, <br />
                1&#8804;<em> i</em> &#8804; <em>п </em>: <br />
                а) родител на <em>A[i] </em>е в <em>A</em><img src="images/tree_image008.gif" alt="8" width="26" height="34" /><em>, </em>ако <em>i &#8800; </em>1;<br />
                б) ляв наследник на <em>A[i] </em>е в <em>A[2i], </em>ако 2i&#8804; <em>n; </em><br />
                в) десен наследник на <em>A[i] </em>е в <em>A[2i </em>+ 1],<strong> </strong>ако 2i + 1&#8804; <em>п . </em><br />
                Дефиниция. <em>Запълнено двоично дърво </em>(complete) е такова, чиито елементи могат да се представят последователно  по правилата на пълно дърво, без &quot;дупки&quot; в последователността.<br />
  <img src="images/tree_image011.jpg" alt="11" width="255" height="133" /><img src="images/tree_image012.jpg" alt="12" width="258" height="161" />&nbsp;<br clear="all" />
              </p>
              <p>Горните два примера показват  съответно запълнено дърво и такова, в което запълнеността е нарушена, тъй като  остават &quot;дупки&quot; в линейната  последователност. Правилата за запълнено дърво са: <br />
                а) разлика в нивата на листата  най-много единица; <br />
                б) всички листа от ниво <em>k </em>са  наляво от кой да е лист от ниво <em>k </em>-1 .  Разликата между пълно и запълнено дърво е, че в запълненото може да ням <br />
                всичките <em>2k </em>-1 елемента, но въпреки това може да се линеаризира като пълн  дърво. Аналогично стоят нещата относно линеаризация на троично или въобще <em>р </em>-ично дърво. <br />
                Обратно,  нека имаме пълно двоично дърво с <em>п </em>елемента. По лема <em>п </em>= <em>2k </em>-1. Следователно за дълбочината <em>k </em>на  дървото имаме <em>k </em>= <em>log2(n+ </em>1). ТО! означава, че в едно пълно  двоично дърво с <em>п </em>елемента максималната дължина н път от корена до лист  е <em>k </em>= log2 <em>(n </em>+ 1). Това е важно свойство за построяване н  ефективни алгоритми за търсене, включване и изключване. <br />
  <u>Представяне на двоично дърво </u><br />
                Тъй като  сега наследниците са най-много два, може да се върнем КЪ' структура на елемент с указатели към всеки от наследниците;  най-често n означаваме като <em>ляв </em>и <em>десен </em>наследници. </p>
              <p><img src="images/tree_image014.jpg" alt="14" width="292" height="101" />&nbsp;</p>
              <br clear="all" />
              <br />
Например:
<p>Операцията <em>инициализация </em>означава създаване на празно дърво и се съст само в анулиране на указателя  на дървото:<br />
    <em>root:= nil; </em><br />
  Операция <em>обход  на дърво: </em><br />
  Ако означим с <em>А </em>даден възел на дървото, а с <em>L </em>и <em>R </em>съответно  лявото и дясно поддървета, които започват от възела <em>А </em><br />
  <img src="images/tree_image016.jpg" alt="16" width="172" height="129" /><em>&nbsp;</em></p>
<p>съществуват  три подхода за обход на дървото, което означава преминаване през всеки възел по  веднъж: </p>
<ol>
  <li>Префиксна форма (preorder) А L R,  което означава преминаване през възела, а след това по същата схема през лявото  и дясното поддървета; </li>
  <li>Инфиксна форма (inorder) L А R ; </li>
  <li>Постфиксна форма (postorder) L R  А . </li>
</ol>
<p>Тези  названия за обход на дървото се свързват с представяне на двуместните перации,  тъй като дървото е удобна структура за представяне на аритметични (и iулеви)  изрази: във вътрешните възли се представят операции, а листата са перанди. Така  например следното дърво, обходено по трите схеми, дава различните записи на аритметичен  израз </p>
<div>
  <table cellspacing="0" cellpadding="0" hspace="0" vspace="0" width="76" height="45">
    <tr>
      <td valign="top" align="left" height="45"><br />
          <em>prefix </em><br />
          <em>inf</em><em>ix</em><br />
          <em>postfix </em> </td>
    </tr>
  </table>
</div>
<p><img src="images/tree_image018.jpg" alt="18" width="170" height="132" />&nbsp;</p>
<div>
  <table cellspacing="0" cellpadding="0" hspace="0" vspace="0" width="115" height="41">
    <tr>
      <td valign="top" align="left" height="41"><br clear="all" />
          <br />
          <em>*+AB-CD (A+B)*(C-D) </em><br />
          <em>AB-CD</em><em>-*</em> </td>
    </tr>
  </table>
</div>
<p>С оглед на  разглежданото по-долу специфично двоично дърво, най-удобна е бъде формата infix  за обход на дървото, която лесно може да се опише курсивно <br />
    <em>алгоритъм  infix(t: ptr); </em><br />
    <em><u>ако</u></em><em> t &#8800; nil <u>то</u></em><br />
    <em>infix(t </em><em>^.l);</em><br />
    <em>nечат(t </em><em>^.</em><em>info); </em><br />
    <em>infix(t^.r);</em><br />
  Рекурсивният характер на дървото  като структура води към рекурсивно определение на операцията обход. <br />
  Относно  операциите включване и изключване ще разгледаме едно конкретно приложение на  двоичното дърво: т. нар. двоично дърво на търсене. <br />
  <em>Двоично  дърво на търсене </em>е  такова двоично дърво, в което ключът на даден възел е по-голям от ключовете на  лявото му поддърво и по-малък от ключовете на дясното му поддърво. <br />
  Ако дърво  с <em>п </em>елемента е пълно, то, както видяхме, най-дългият път от корена до лист е <em>h </em>= <em>l</em><em>og2(n </em>+  1). Следователно, в такова дърво търсенето, а  и включването и изключването се осъществяват с алгоритми със сложност  O(log n). </p>
<p><img src="images/tree_image020.jpg" alt="20" width="322" height="137" />&nbsp;<br clear="all" />
</p>
<p>Операцията <em>търсене </em>на елемент еъс зададен ключ <em>х </em>в дърво с корен <em>root </em>използва  основното свойство на двоичното дърво на търсене и след всяка операция  сравнение определя поддърво, ляво или дясно, в което да продължи търсенето.  Това означава, че се извършват най-много <em>h </em>= <em>log2(n+ </em>1)  сравнения. <br />
    <em>алгоритъм  search(root:ptr,x: integer,</em><em>f</em><em>l: boolean); </em><br />
    <em>f</em><em>l:=false; </em><br />
    <em>p:=root; </em><br />
    <em><u>докато</u></em><em> р </em>&#8800;<em>n</em><em>il</em><em> and р </em><em>^</em><em>.info </em>&#8800; <em>х </em><em><u>прави</u></em><br />
    <em><u>ако</u></em><em> х </em>&gt; <em>р </em><em>^</em><em>.info <u>то</u></em><em><u> </u></em><br />
    <em><u> </u></em><em>p:=p^.r<u></u></em><br />
    <em><u>иначе</u></em><br />
    <em>p:=p</em><em>^</em><em>.l; </em><br />
    <em><u>ако</u></em><em>р&#8800;</em><em>nil </em><em><u>то</u></em><br />
    <em>операция </em>с <em>р</em><em>^</em><em>.info; </em><em>f</em><em>l </em>:= <em>trие; </em><br />
  Ако обърнем внимание на това, че  структурата дърво има рекурсивен характер, то горният алгоритъм може да се  представи в рекурсивна форма.<br />
  Операциите  включване и изключване на елемент актуализират дървото. Те тбва да се осъществят така, че след  актуализацията дървото отново да бъде эично дърво на търсене. При <em>включване </em>новият  елемент се добавя като входяш по посока, ляв или десен, наследник на лист от  дървото. Стъпките, по се извършват за реализиране на операцията, са: вземане на  място за :мента в свободното пространство; търсене на място за включване на  елемента, което се изпълнява с <em>O</em><em>(</em><em>l</em><em>og2(n+ </em>1)) операции сравнения и  привързване на елемента ьрвото, което се изпълнява с константен брой операции. <br />
  Операцията <em>изключване </em>на  елемент със зададен ключ <em>х </em>е малко по-сложна, тъй изключваният елемент  може да се намира на произволно ниво в дървото. а трябва да се реши въпросът с  неговите наследници. Ако в някоя от двете посоки липсва наследник на  изключвания елемент, то единственият такъв ще заеме мястото на изключвания  елемент и дървото ще удовлетворява свойството на двоично дърво на търсене. </p>
<p><img src="images/tree_image023.jpg" alt="23" width="105" height="151" /><img src="images/tree_image024.jpg" alt="24" width="121" height="143" />&nbsp;<br clear="all" />
</p>
<p>В общия случай, когато изключваният  елемент има и двата си наследника, може да се възприеме следната стратегия:  единият наследник, например левият, заема мястото на изключвания елемент;  другият му наследник (с цялото си поддърво) се включва вместо най-десен лист на  поддървото започващо от първия наследник.</p>
<p><img src="images/tree_image026.jpg" alt="26" width="196" height="280" />&nbsp;</p>
</div>
 <a style="display:scroll;position:fixed;bottom:10px;right:10px;" href="#" title="В началото"><img width="30" height="30" src="images/button.png"/></a>  
</div>
	
<div id="footer">
			<p>&copy; Copyright Synthesis and Analysis of Algorithms &middot; 2017 &middot; Design: Elitsa Nikolova&middot; 
			 
			  <a href="index.html"><span>Алгоритми</span></a>&middot;
              <a href="struct.html"><span>Структури данни</span></a>&middot;
               <a href="metods.html"><span>Методи за създаване</span></a>&middot;
               <a href="sort.html"><span>Алгоритми за сортиране</span></a>&middot;
		    <a href="map.html"><span>Карта на сайта</span></a></p>
</div>
</body>
</html>