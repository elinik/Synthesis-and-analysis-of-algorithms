<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-5" />
	<meta name="Author" content="Elitsa Nikolova" />
	<meta name="Robots" content="index,follow" />
	<meta name="Description" content="Synthesis and Analysis of Algorithms" />
	<meta name="Keywords" content="Synthesis,Analysis,Algorithms" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<title>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</title>
    <style type="text/css">
<!--
.style1 {
	font-size: 1.2em;
	color: #333333;
}
.style7 {font-size: 1.2em}
.style13 {font-size: 0.7em}
-->
    </style>
</head>
<body>
	<div id="main">
<ul id="menu">
<li><a href="sort.html"><span class="key">Алгоритми за сортиране</span></a></li>
            <li><a href="metods.html"><span class="key">Методи за създаване</span></a></li>
            <li><a href="struct.html"><span class="key">Структури данни</span></a></li>
            <li><a href="index.html"><span class="key">Алгоритми</a></li>
</ul>
		
  <div id="intro_left">
			<p>Алгоритмите в сайта са описани на псевдокод, което ги прави по-лесни за четене и разбиране.</p>
	  </div>
		
		<div id="intro_right">
			<p class="white">УЕБ БАЗИРАНО ПРИЛОЖЕНИЕ ПО</p>
		  <h1>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</h1>
			<p></p>
		</div>

  <ul id="menu_left">
			<li><a href="index.html"><span>Алгоритми, изисквания, описание</span></a></li>
			<li><a href="analyses.html"><span>Анализ на алгоритми. Изчислителна сложност. Класификация</span></a></li>
		<li><a href="recursion.html"><span>Рекурсия</span></a></li>
		<li><a href="task01.html"><span>Задачи</span></a></li>
	  </ul>


			<div class="special">
			  <h1>&nbsp;</h1>
			  <h1> Анализ на алгоритми. Изчислителна сложност. Класификация</h1>
			  <p> <br />
			    Едно  от важните изисквания към алгоритмите засяга тяхната ефективност. Ефективността  на алгоритмите се отнася към използваните ресурси - време и памет - за  изпълнението им. За да може да се оцени ефективността, е необходима количествена  мярка за това. Ролята на такава мярка играе понятието изчислителна  сложност или сложност на  алгоритъм. Според това какво се оценява - време или количество необходима  памет, сложността бива времева или пространствена.<br />
			    Да  направим анализ на един алгоритъм  означава да определим количествената мярка сложност на този алгоритъм. На  практика се оказва, че по- важната характеристика за един алгоритъм е неговата  времева сложност, затова тук ще обръщаме внимание именно на нея. <br />
			    Защо  е необходим анализ на сложността на един алгоритъм? Основните причини са две: </p>
			  <ul>
			    <li>Ако за решението на дадена задача разполагаме с повече от  един алгоритъм, естествено е да изберем този, който изисква по-малко време (или  памет), за да бъде изпълнен. За това е необходима количествена мярка, за да се  направи сравнение. </li>
			    <li>Ако сме разработили алгоритъм за решение на дадена задача, е  необходимо да оценим дали той е използваем. </li>
		      </ul>
			  <p>Илюстрация на последната причина ще направим отново със  задачата на търговския пътник. Търговският пътник се намира в едно от п  населени места и трябва да посети всичките по веднъж. Всеки две населени места i и j,  (i,j = 1..n) са свързани с път, цената на който е елемент сij на  една квадратна матрица C = {c<em>ij</em>} от п-ти  ред. Диагоналните елементи на тази матрица са сii  = 0, които очевидно не се използват. Да приемем, че пътникът се намира в  първото населено място; той трябва да премине през всяко от останалите и да се  върне в отправното. Очевидно, той може да направи това по много различни  маршрути, всеки от които има обща цена, равна на сумата от елементите с- между  последователността от <br />
			    населени  места, включени в дадения маршрут. Целта е да се определи онзи маршрут, който  има най-малка обща цена. По-горе видяхме, че алгоритъмът, който ползва идеята  за най-близък съсед, не гарантира оптималното решение и в този смисъл не е  правилен. <br />
			    Решение: <br />
			    Ще  разработим алгоритъм, който формира всички възможни маршрути, изчислява цените  им и от тях избира онзи с най-малка цена (изчерпващ алгоритъм). За описанието  му няма да влизаме в детайли, тъй като не това е целта. Преди всичко да изясним  колко различни маршрути има при п  населени места. След като търговският пътник се намира в първото населено място  и трябва след обиколката на населените места от 2 до и да се върне пак там, то  всички възможни маршрути се дават от всички пермутации на числата от 2 до п. Това  са п-1 числа, следователно всички маршрути са (n-1)! По същество  основата на алгоритъма е избор на минимален елемент от едно множество на цените  на всеки един от маршрутите, които трябва последователно да се формират. <br />
			    Описание  на алгоритъма на псевдокод: <br />
			    costmin:=<img src="images/analyses_clip_image002.gif" alt="image22" width="14" height="19" />; <br />
			    за i:= \ до (n-1)! прави <br />
			    определи поредна пермутация Р на числата от 2  до п; <br />
			    определи маршрут Т(Р); <br />
			    изчисли cost(T) = ? от цените на Т(Р); <br />
			    ако  cost(T) &lt; costmin mo <br />
			    costmin: =cost(T); <br />
			    tourmin:=T; <br />
			    В  това описание не сме детайлизирали начина на определяне на поредна пермутация;  да приемем, че това става с една операция. Същественото в този алгоритъм е, че  за определяне на cost(t) се  извършват п операции събиране на събираемите c-j, които  участват в текущия маршрут. Като пренебрегнем всичко останало, имаме (n-1)! пъти извършването  на и събирания. Следователно броят събирания в този алгоритъм е n.(n-1)! = n!. <br />
			    Нека п = 20,  т.е. трябва да се обиколят 20 населени места, а алгоритъмът се изпълнява на  компютър с 109 операции събиране/секунда. Да пресметнем колко време  е необходимо за работата на алгоритъма на такъв компютър. Като отчетем, че 20!<img src="images/analyses_clip_image004.gif" alt="image42" width="12" height="19" />2.1018, то  алгоритъмът ще работи 2.109 секунди. Последователното превръщане на  секундите в минути, часове, дни, години се дава от<br />
  <img src="images/analyses_clip_image006.gif" alt="image62" width="189" height="38" /><br />
  <br />
			    Това показва, че описаният алгоритъм: </p>
			  <ul>
			    <li>изчерпва всички възможни случаи и  определя наи-ниската цена, следователно е правилен; </li>
			    <li>лек е за четене; </li>
			    <li>удобен е за модификация, но практически е неизползваем (за  големи стойности на п). </li>
		      </ul>
			  <p>Поради това, независимо от развитието на компютърната  техника, оценката за ефективността на един алгоритъм е изключително важен  елемент от процеса на разработката и реализацията му.</p>
			  <h3 class="blue">Оценка  за сложност на алгоритъм <br />
		      </h3>
			  <p> Първата  стъпка при анализа на сложност на даден алгоритъм е определянето на размерността на  задачата, решавана с него. Размерността е параметър (или параметри), който  определя обема на обработваните данни. За всяка задача може да се определи  такъв параметър; да го означим с п. В  задачата на търговския пътник това е броят на населените места, които трябва да  се посетят; в задача за решаване на система линейни уравнения това е броят на  неизвестните; в задача за сортиране това е броят на елементите, подлежащи на  сортиране и т.н. <br />
			    Следващата  стъпка е определяне на функция f(n) на този параметър, стойността  на която дава необходимото време (или памет) за работата на алгоритъмът при  обработката на п  данни. Именно тази функция f(n) наричаме  сложност на алгоритъма. Важно е  да се отбележи, че ако с f(n) мери необходимото  време, то това зависи не само от самия алгоритъм, но и от използвания език за  програмиране и също от компютъра, на който се изпълнява алгоритъма. Затова, за  да имаме независима от конкретната  реализация оценка, обикновено представяме /(и) като брой  операции, а не време; и то обикновено не всички операции, а  характерните за дадена задача операции. Например, при оценката на даден  алгоритъм за решаване на система линейни уравнения се отчитат аритметичните  операции, и то умноженията, като преобладаващи над деленията и по-бавни от също  преобладаващите събирания. При алгоритъм за сортиране характерни са операциите  сравнения и т.н. <br />
			    Понякога  за даден алгоритъм можем да получим за /(и) явна формула, зависеща от п,  с точност до някои константи, зависещи от реализацията. В  повечето случаи обаче, за да сравним два алгоритъма, или за да оценим  използваемостта на един алгоритъм, е достатъчно да получим т.нар. асимптотична  оценка за f(ri) чрез  означението О (О голямо). <br />
			    Дефиниция. Казваме, че f(n) = О(g(n)) (f(n) е О голямо от g(n)), където  g(n) е  известна функция на п, ако  отношението </p>
			  <p><img src="images/analyses_clip_image008.gif" alt="image82" width="25" height="30" /> <img src="images/analyses_clip_image010.gif" alt="image102" width="49" height="19" /> <em>C=const</em><img src="images/analyses_clip_image012.gif" alt="image122" width="4" height="19" /></p>
			  <p>Това  означава, че при големи стойности на <em>n</em> (<em>n??</em>)  двете функции имат подобно поведение и след като познаваме поведението на g(n),  защото е известна функция, то познаваме и това на <em>f</em>(<em>n</em>) - сложността на  алгоритъма. <br />
Някои  често срещани техники за оценка на сложност</p> <br />
 <h3 class="blue">Сумиране  на аритметична прогресия</h3>
			  <p> <br />
			    Като  пример да разгледаме задачата за сортиране на елементите на масив, използвайки  един от трите базови алгоритъма - този на пряка селекция. При този метод за  всяко поредно място в масива се избира (селектира) подходящият елемент. При  сортиране във възходящ ред за първото място се избира най-малкият от всички  елементи и се премества там, за второто място се избира най-малкият от  останалите елементи и се премества там и т.н.Когато между последните два  елементи се определи по-малкият и се постави на п-1  място, то най-големият очевидно е на <em>n</em>-то  място и масивът е сортиран. Като първа стъпка алгоритъмът може да бъде описан  така: за i := 1 до  п -1 прави </p>
			  <ol>
			    <li>
                  <div>
                </li>
		      </ol>
			  <p><em>i?j?n</em></p>
			   &nbsp;определи хк = min xj
              <ol>
                <li>размени местата на хi и хk </li>
              </ol>
              <p>От  описанието се виждат няколко важни неща: </p>
              <ol>
                <li>тялото на цикъла по i се  изпълнява n-1 пъти;</li>
                <li>при всяко изпълнение на това тяло изпълнението на стъпка 1.  изисква  n-i сравнения,  защото се търси минимум на n-i+1  елемента; </li>
                <li>при всяко изпълнение на тялото операциите за извършване на стъпка  2. не зависят от п, т.е.  са константен брой. </li>
              </ol>
              <p>На следваща стъпка на  детайлизация може да опишем алгоритъма до ниво което може да се напише  програма: <br />
                за<em> i</em>:= 1 до п-1 прави <br />
                xmin:=x[i]; k:=i; <br />
                за j:=i+1 до  п прави <br />
                ако х[j] &lt; xmin  то <br />
                xmin:=x[j]\; k:=j; <br />
                x[k] := <em>х</em>[<em>i</em>]; х [<em>i</em>] := xmin; <br />
                Нека с0  = const са  броят операции, с които се реализира едно сравнение на елемента, а с1 = const са  броят машинни операции, с които два елемента разменят местата. Какви са  стойностите на тези константи не е толкова вая важно е, че те не зависят от п.  Тогава да сумираме броя операции за всяка стойност на i: <br />
                <img src="images/analyses_clip_image002_0000.gif" alt="20" width="14" height="19" />(n-1) +<img src="images/analyses_clip_image004_0000.gif" alt="40" width="14" height="19" />+<img src="images/analyses_clip_image002_0001.gif" alt="21" width="14" height="19" />(n-2) +<img src="images/analyses_clip_image006_0000.gif" alt="60" width="17" height="19" />+...+<img src="images/analyses_clip_image008_0000.gif" alt="80" width="62" height="19" />=</p>
              <p>              <img src="images/analyses_clip_image002_0002.gif" alt="22" width="14" height="19" />(n-1 +<img src="images/analyses_clip_image010_0000.gif" alt="100" width="4" height="19" />n-2 +...+<img src="images/analyses_clip_image012_0000.gif" alt="120" width="48" height="19" />(n-1)=</p>
              <p><img src="images/analyses_clip_image014.gif" alt="image142" width="342" height="36" /> </p>
              <p>За <em>f</em>(<em>n</em>) получихме един полином от втора степен на п, за който се вижда, че <br />
                <img src="images/analyses_clip_image016.gif" alt="image162" width="375" height="47" /> </p>
              <br clear="all" />
              <p>и  следователно асимптотичната оценка на алгоритъма за пряка селекция е О(n2). </p>
              <p>Основната  техника, която използвахме тук, е сумиране на аритметична прогресия.<br />
 Да разгледаме още един пример, този път с  метода на мехурчето сортиране във възходящ ред на масив. Казваме, че два  съседни елемента аi и аi+1 са в  инверсия, ако е нарушено изискването аi ?аi+1  аi  ам, т.е. когато аi &gt;аi+1.  Идеята ce състои  в последователни сканирания на масива и когато се установи инверс между два  съседни елемента, тя се отстранява, като двата елемента си размес местата. Едно  такова проследяване не гарантира сортирането на целия масив, гарантира, че най-големият  елемент, където и да е бил първоначално, ще отиде последно място. Тогава  второто сканиране следва да се проведе до n ? 1-вия елемент,  третото до  n ? 2-рия и  т.н. Когато е отстранена и евентуалната инверс между първите два елемента,  масивът е сортиран. Този алгоритъм може да опише така:</p>
              <p>k:=n;<br />
                  <u>докато</u> k&gt;1 <u>прави</u><br />
                  <u>за</u> i:=1 до k-1 <u>прави</u><br />
                  <u>ако</u> ai&gt;ai+1 <u>то</u><br />
                swap(ai,ai+1);<br />
                k:=k-1;<br />
  <img src="images/analyses_clip_image001.gif" alt="12i" width="48" height="22" /><br clear="all" />
  <br />
                Тук процедурата swap(u,v) разменя  местата на два елемента; съществено е, че  броят  операции, с които се реализира, не зависи от п. <br />
                Лесно  може да се докаже, че ако при едно поредно сканиране на съответната част на масива не се открие инверсия, то масивът е сортиран  още на този етап и е излишно  последващото му сканиране. Това може да се отрази в алгоритъма с въвеждането на една булева променлива, чиято стойност , true или false, да отразява съответно имало ли е инверсия при поредното  сканиране или не. С нейното  участие алгоритъмът ще изглежда така: <br />
                k := п; flag := true; <br />
                докато k &gt;  1 and flag прави <br />
                flag := false; <br />
                за i := 1 до k -1 прави <br />
                ако ai&gt;ai+1 mo           <br />
                swap(ai,ai+1);flag := true; <br />
                k:=k-1; <br />
                Нека  сега преброим операциите в този алгоритъм. Преди входа в цикъла по k се изпълняват две присвоявания с константен брой операции.  Тялото на цикъла по k се  изпълнява в най-лошия случай п-1 пъти. За всяка  стойност на k тялото  на цикъла по i  се изпълнява k-1  пъти, а в него има едно сравнение с константен брой операции и евентуално  четири присвоявания, също с константен брой операции. Освен това в тялото на  цикъла по к има и две присвоявания, броят на операциите за които също не  зависи от n.  Тогава, в най-лошия случай, броят операции ще бъде: <br />
  <em>            c2 + </em><img src="images/analyses_clip_image003.gif" alt="32" width="14" height="19" /><em>(n-1)  +</em><img src="images/analyses_clip_image005.gif" alt="52" width="14" height="19" /><em>+</em><img src="images/analyses_clip_image003_0000.gif" alt="30" width="14" height="19" /><em>(n-2)  +</em><img src="images/analyses_clip_image007.gif" alt="72" width="17" height="19" /><em>+...+</em><img src="images/analyses_clip_image009.gif" alt="92" width="62" height="19" /><em>=</em></p>
              <p><em>           c2+</em><img src="images/analyses_clip_image003_0001.gif" alt="31" width="14" height="19" /><em>(n-1  +</em><img src="images/analyses_clip_image011.gif" alt="112" width="4" height="19" /><em>n-2 +.+</em><img src="images/analyses_clip_image013.gif" alt="132" width="48" height="19" /><em>(n-1)=</em></p>
              <p><img src="images/analyses_clip_image015.gif" alt="152" width="411" height="36" /> <br />
                т. е. алгоритъмът отново има сложност O(<em>n</em>2). Броят операции, с които се изпълнява  този алгоритъм, обаче зависи от първоначалната подредба на елементите в масива.  Това, което преброихме, са операциите в най-лошия случай, когато масивът е зададен  подреден в низходящ ред. Ако масивът е подреден първоначално в искания вид, то  както може да се види леко, ще се изпълни самс едно влизане в тялото на цикъла  по k и броят операции ще  бъде: <br />
  <em>c</em>2<em>+c</em>0(<em>n-1</em>)<em>+c</em>1<em>=</em> O(<em>n</em>),<br />
                т.е.  алгоритъмът ще работи с линейна сложност. Както също може леко да се види,  алгоритъмът с пряка селекция , независимо от първоначалната подредба на  елементите, ще работи с всичките си O(<em>n</em>2) операции. <br />
              <h3 class="blue">Изчисляване  на рекурентни формули</h3>
                
                Често  даден алгоритъм за решение на някаква задача може да се опише така: за да се  реши задачата с размерност п, се  изпълняват определен брой операции, с което задачата се свежда към същата, но с  по-малка размерност. Например, алгоритъмът за сортиране с пряка селекция може  да се опише така: за да сортираме масив с п  елемента, изпълняваме п-1  сравнения и свеждаме задачата към същата - за сортиране, само че на п-1  елемента. Щом свеждането е към същата задача, тя ще има същата функция на сложност,  само че с аргумент п -1. Следователно  при изразяването на f(п)  получаваме рекурентната формула <br />
                f(n)=С.(n  -1) + f (n-1). <br />
                Ако  развием тази формула, като заместваме f отдясно чрез получената  формула, ще имаме: <br />
                f (n) = С(n-1) + f (n -1) = С(n-1) + С(n-2) + f (n -2) = <br />
                = ... = С(n-1) + С(n-2) +.+<em>С</em>.1 + <em>f </em>(1) <br />
                Тук <em>f </em>(1) е броят операции за  сортиране на масив от един елемент, но такъв масив е винаги сортиран,  следователно <em>f </em>(1) = 0. Така отново  получаваме <br />
                f(n)=С(n -1+n-2+.+1)=C<img src="analyses_clip_image017.gif" alt="172" width="38" height="28" />=O(n2)</p>
              <p>Друг  пример за рекурентна формула ще получим, ако даденият алгоритъм може да се  опише така: за решение на задача с размерност п се  извършват операции, чийто брой е пропорционален на и и задачата се свежда до  две задачи от същия вид, но всяка от тях с два  пъти по-малка размерност (подход "разделяй и владей"). Тогава  рекурентната формула за сложността f(n) на  такъв алгоритъм ще бъде <br />
                f (n)=Сn +2f <img src="images/analyses_clip_image019.gif" alt="192" width="23" height="29" />. </p>
              <p>За да  получим затворена формула за f(n) като  функция на п, отново заместваме рекурентната  формула за f  отдясно (за простота да приемем, че п е  степен на двойката): <br />
                f (n) = Сn +2f <img src="images/analyses_clip_image021.gif" alt="212" width="26" height="29" />= Сn+2<img src="analyses_clip_image023.gif" alt="232" width="102" height="34" />=.=<br />
                3Сn+<img src="images/analyses_clip_image025.gif" alt="252" width="16" height="19" />f<img src="images/analyses_clip_image027.gif" alt="272" width="28" height="29" /> =.= kCn+2k <img src="images/analyses_clip_image029.gif" alt="292" width="36" height="29" />,<br />
                като  заместваме дотогава, докато <img src="images/analyses_clip_image031.gif" alt="312" width="13" height="25" />=1 ?  n = 2k, k=<img src="images/analyses_clip_image033.gif" alt="332" width="40" height="19" />. Да приемем още, че се  касае за алгоритъм за сортиране (така е например при алгоритъма за сортиране quicksort), т.е. f(1) =  0; тогава <br />
                f (n) = log2  пСп + nf (1) = Сп log2  n = O(n log2 п) <br />
                Получихме  оценка O(n  log2 п),която е по-добра от O(n2),  защото едната степен на n е  заменена с по-бавно растящата функция log  n. <br />
                И от двата примера се вижда още, че за да се приложи една  рекурентна формула, е необходимо задаването на една (в някои случаи и повече)  стартова стойност; в разгледаните случаи f (1). </p>
            <h3 class="blue">Класификация  на алгоритмите според сложността им </h3>
  <p>При  тази класификация п е размерността на задачата и отразява обема на обработваните  данни, например степен на полином, брой на елементи за сортиране, брой възли в  даден граф и т.н. Ще разглеждаме различните често използвани функции g(n),  които играят ролята на известната функция в дефиницията за сложност. </p>
              <ol>
                <li>g(n) = const </li>
              </ol>
              <p>Този  случай рядко се среща и се отнася за ситуация, в която за обработката на п данни се извършват  операции, чийто брой не зависи от п. Такъв например е случаят, в който се определя адрес на  елемент от масив с п елемента. В този случай се прави адресно изчисление и се  осъществява пряк  достъп до елемента, без значение колко голям е масивът: <br />
                Адрес (A[i]) = А0 + (i-1)* дължината на думата </p>
              <ol>
                <li>g(n) = logп, логаритмична оценка </li>
              </ol>
              <p>Такава  оценка има алгоритъм, който решава сложна задача, като я трансформира в такава  с пъти по-малка размерност. Например алгоритъмът за двоично търсене в подреден  масив прави точно това: с едно сравнение със средния елемент, което се извършва  с константен брой операции, свежда задачата към същата, но с два пъти по-малка  размерност: <br />
                f(n)  = C + f<img src="images/analyses_clip_image002_0003.gif" alt="2a" width="23" height="29" />, f(1) = C<br />
                Характерно  за логаритмичната оценка е, че необходимият брой операции за изпълнението на  алгоритъма нараства по-бавно от нарастването на размерността п. </p>
              <ol>
                <li>g(n) = п, линейна сложност </li>
              </ol>
              <p>Такава  сложност има алгоритъм, който извършва някаква обработка за всеки един елемент  от п  входа. Обикновено това се реализира с един цикъл. </p>
              <ol>
                <li>g(n) = п log  п,  линеаристична оценка </li>
              </ol>
              <p>Обикновено  такава оценка има алгоритъм, разработен с метода "разделяй и владей". Такава  оценка имат методите за сортиране quicksort и mergesort,  които ще разгледаме по-нататък. </p>
              <ol>
                <li>g(n) = n2, квадратична  оценка </li>
              </ol>
              <p>Такава  оценка имат алгоритми, които трябва да извършат някаква обработка за всяка  двойка елементи от п входа. Обикновено те се реализират с два вложени един в друг  цикъла. </p>
              <ol>
                <li>g(n) = n3,  кубична оценка </li>
              </ol>
              <p>Такава  оценка се получава, ако алгоритъмът се реализира с три вложени един в друг  цикъла. Такива са например универсалните алгоритми (Гаус) за решаване на  линейни системи с п неизвестни. </p>
              <ol>
                <li>g(n) = an, експоненциална  сложност. </li>
              </ol>
              <p>Времето  за изпълнение на такъв алгоритъм нараства драстично с нарастването на п. Обикновено това са  изчерпващи алгоритми за комбинаторни задачи. Например g(n) = 2n при  задача за генериране на всички комбинации на комбинационен ключ с п позиции, всяка от които  има две състояния. Към този случай спада и оценката п\ при задачата на  търговския пътник. <br />
                Илюстрация  за растенето на съответната функция g(n) при  нарастването на п дава следната таблица. </p>
              <table border="1" cellspacing="1" cellpadding="1">
                <tr>
                  <td valign="top"><p>n <br />
                  g(n) </p></td>
                  <td valign="top"><p>5 </p></td>
                  <td valign="top"><p>10 </p></td>
                  <td valign="top"><p>20 </p></td>
                  <td valign="top"><p>100 </p></td>
                </tr>
                <tr>
                  <td valign="top"><p>log2    п </p></td>
                  <td valign="top"><p>2.322 </p></td>
                  <td valign="top"><p>3.322 </p></td>
                  <td valign="top"><p>4.322 </p></td>
                  <td valign="top"><p>6.6438 </p></td>
                </tr>
                <tr>
                  <td><p>п </p></td>
                  <td><p>5 </p></td>
                  <td valign="bottom"><p>10 </p></td>
                  <td valign="bottom"><p>20 </p></td>
                  <td valign="bottom"><p>100 </p></td>
                </tr>
                <tr>
                  <td valign="top"><p>n log2    n </p></td>
                  <td valign="bottom"><p>11.61 </p></td>
                  <td valign="top"><p>33.22 </p></td>
                  <td valign="top"><p>86.44 </p></td>
                  <td valign="top"><p>664.38 </p></td>
                </tr>
                <tr>
                  <td valign="bottom"><p>п2 </p></td>
                  <td valign="bottom"><p>25 </p></td>
                  <td valign="bottom"><p>100 </p></td>
                  <td valign="bottom"><p>400 </p></td>
                  <td valign="bottom"><p>10 000 </p></td>
                </tr>
                <tr>
                  <td valign="top"><p>2n </p></td>
                  <td valign="top"><p>32 </p></td>
                  <td valign="top"><p>1024 </p></td>
                  <td valign="top"><p>(1024)2 </p></td>
                  <td valign="top"><p>(1024)10 </p></td>
                </tr>
              </table>
              <p>&nbsp;</p>
              <p>&nbsp; </p>
              <h1 align="center">&nbsp;</h1>
			  <h1 align="center">&nbsp;</h1>
	  </div>
	   <a style="display:scroll;position:fixed;bottom:10px;right:10px;" href="#" title="В началото"><img width="30" height="30" src="images/button.png"/></a>  
</div>
	
<div id="footer">
			<p>&copy; Copyright Synthesis and Analysis of Algorithms &middot; 2017 &middot; Design: Elitsa Nikolova&middot; 
			 
			  <a href="index.html"><span>Алгоритми</span></a>&middot;
              <a href="struct.html"><span>Структури данни</span></a>&middot;
               <a href="metods.html"><span>Методи за създаване</span></a>&middot;
               <a href="sort.html"><span>Алгоритми за сортиране</span></a>&middot;
		    <a href="map.html"><span>Карта на сайта</span></a></p>
</div>
	
</body>
</html>>