<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-5" />
	<meta name="Author" content="Elitsa Nikolova" />
	<meta name="Robots" content="index,follow" />
	<meta name="Description" content="Synthesis and Analysis of Algorithms" />
	<meta name="Keywords" content="Synthesis,Analysis,Algorithms" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<title>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</title>
    <style type="text/css">
<!--
.style1 {
	font-size: 1.2em;
	color: #333333;
}
.style7 {font-size: 1.2em}
.style13 {font-size: 0.7em}
-->
    </style>
</head>
<body>
	<div id="main">
<ul id="menu">
<li><a href="sort.html"><span class="key">Алгоритми за сортиране</span></a></li>
            <li><a href="metods.html"><span class="key">Методи за създаване</span></a></li>
            <li><a href="struct.html"><span class="key">Структури данни</span></a></li>
            <li><a href="struct.html"><span class="key">Алгоритми</span></a></li>
</ul>
		
  <div id="intro_left">
			<p>Алгоритмите в сайта са описани на псевдокод, което ги прави по-лесни за четене и разбиране.</p>
	  </div>
		
		<div id="intro_right">
			<p class="white">УЕБ БАЗИРАНО ПРИЛОЖЕНИЕ ПО</p>
		  <h1>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</h1>
			<p></p>
		</div>

	  <ul id="menu_left">
		<li><a href="metods private.html"><span>Метод на частните цели</span></a></li>
		<li><a href="metods evristic.html"><span>Евристични алгоритми</span></a></li>
		<li><a href="metods search.html"><span>Изчерпващо търсене с възврат</span></a></li>
        <li><a href="metods dyn.html"><span>Метод на динамичното програмиране</span></a></li>
		<li><a href="task03.html"><span>Задачи</span></a></li>
	  </ul>


			<div class="special">
			  <h1> Метод на динамичното  програмиране </h1>
			  <p>Методът  на динамичното програмиране се използва за съставяне на алгоритми за  комбинаторни задачи. Той се прилага, когато решението на задачата може да се  разглежда като последователност от решения на отделни подзадачи. Например една  такава задача е тази за намиране на най-къс път между два възела в един  ориентиран граф. Тя може да се разглежда на стъпки: първо решаваме кой да е  втори възел, след това кой да е трети и т.н. Оптималната последователност от  решения ще бъде онази, която дава най-късия път. <br />
			    Една  възможност да намерим най-късия път е, разбира се, да намерим всички пътища  между двата възела, и от тях да изберем най-късия, т.е. да приложим метода на  &quot;бруталната сила&quot;. Динамичното програмиране често драстично намалява  претърсването чрез избягване на такива варианти, които не биха довели до  оптимален път. Динамичното програмиране може да се приложи за задачи, за които  важи принципът за оптималност на Белман. Той гласи: <br />
  <em>Принцип  за оптималност: </em>Една  оптимална последователност от решения има това свойство, че каквото и да е  началното състояние и решението, взето в него, останалите решения трябва да  съставят оптимална последователност относно състоянието, до което това решение  е довело. <br />
			    Да  разгледаме някои свойства на последователността от решения за задачи, за които  принципът за оптималност е в сила. Нека отново разглеждаме задачата за най-къс  път между два възела <em>i </em>и <em>j</em>в  ориентиран граф. </p>
			  <ol>
			    <li>Нека <em>i</em>, <em>i1</em>, <em>i2</em>,..,<em>ik</em>, <em>j</em>е най-късият път от <em>i</em> до <em>j. </em>Тогава най-късият път от <em>i1</em> до <em>j </em>се дава от последователността <em>i</em>, <em>i1</em>, <em>i2</em>,..,<em>ik</em>, <em>j.</em>Наистина, ако допуснем, че  съществува по-къс <em>i</em><em>1</em><em>,  p2, ., pm, j, </em>от <em>i1 </em>до <em>j</em><em>, </em>то <em>i</em>, <em>i</em><em>1</em><em>,  p2, ., pm, j, </em>ще  бъде по-къс път от <em>i</em>, <em>i1</em>, <em>i2</em>,..,<em>ik</em>, <em>j</em><em>, </em>което  противоречи на началната предпоставка. Следователно след решението <em>i</em> - <em>i</em><em>1</em>, оставащата последователност е  оптимална по отношение на състоянието <em>i</em><em>1</em>. Оттук следва, че принципът за  оптималност е в сила за задачата за най-къс път.</li>
			    
			  <img src="images/metods dyn_image002.jpg" alt="2" width="302" height="152" />
			    <li>Нека <em>Qi</em> е множеството на възли, съседни  на <em>i</em>-тия възел. Нека за всяко <em>k</em><img src="images/metods dyn_image004.gif" alt="4" width="10" height="19" /><em>Q</em><em>i</em><em>, </em>Г<em>k </em>да е най-късият  път от <em>k </em>до <em>j. </em>Тогава  най-късият път от <em>i</em> до <em>j </em>е най-късият от пътищата{&lt; <em>i, k</em>&gt; + Г<em>k, (k</em><img src="images/metods dyn_image004_0000.gif" alt="40" width="10" height="19" /><em>Q</em><em>i</em><em>)</em><em>}. </em></li>
			  </ol>
			  <ol>
			    <li>Нека <em>i,</em><em>i</em><em>1</em><em>, </em><em>i2,  ... ,</em><em>k,</em><em> p1, p2</em><em>,  ... ,</em><em>j </em>е  най-късият път от <em>i</em> до <em>j</em>, където <em>k</em> е междинен възел в този най-къс  път. Тогава пътят <em>i</em>, <em>i1</em>, <em>i2</em>,..,<em>k </em> и пътят <em>k,</em><em> p1,  p2</em><em>,  ... ,</em><em>j</em>са  най-късите съответно от <em>i </em>до <em>k</em> и от <em>k </em>до <em>j. </em> </li>
			    <li>Нека P<em>j</em> е множеството на възли, съседни на последния възел <em>.</em>Нека за  всяко <em>k </em><img src="images/metods dyn_image004_0001.gif" alt="41" width="10" height="19" /><em>Pj, </em>Г<em>k </em>е най-късият път от <em>i </em>до <em>k.</em> Тогава най-късият път от <em>i </em>до <em>j </em>е най-късият  от пътищата {Г<em>k</em>+<em>k</em>, <em>j </em>&gt;, <em>k</em><img src="images/metods dyn_image004_0002.gif" alt="42" width="10" height="19" /><em>Pi</em>}. </li>
		      </ol>
			  <p><img src="images/metods dyn_image006.jpg" alt="6" width="332" height="185" />&nbsp;<br clear="all" />
              </p>
			  <p><span class="blue"><u>Задача за  намиране на критичен път в мрежов график</u>.</span> <br />
                Ще  разгледаме една практическа задача за планирането и управлението на един  комплекс от дейности, съставящи някакъв сложен процес: проектиране,  строителство, технологична верига и т.н. Всяка от отделните дейности изисква определено  време. Дадена дейност може да започне да се извършва, след завършила друга  дейност, която я предпоставя. Тези връзки между определени дейности могат да се  представят чрез мрежа по следния начин. Началният момент на започване на целия  комплекс от дейности се представя с началния възел в мрежата. От него излизат насочените ребра на онези дейности, които  могат да започнат още в началото. Възел в мрежата представя момент, в който завършва  дейност, представена с входящо във възела ребро и момент, в който може да  започне дейност, представена с изходящо от възела ребро. Последният възел в мрежата  има само входящи в него ребра и представя момента, в който целият комплекс от  дейности завършва. С всяко ребро е съпоставено реално число <em>tij,</em> което представя времето, необходимо за извършване на  съответната дейност. Мрежата, представяща  комплекса от дейности, се нарича <em>мрежов график. </em>Най-краткото време за изпълнение на целия комплекс от дейности  се определя от най-дългия път, който свързва началния с крайния възел в  мрежата, и се нарича <em>крит</em><em>ичен път </em>в мрежовия график. Така се  нарича, защото ако се получи забавяне на някоя дейност, която не влиза в  критичния път, това може и да не е фатално за спазване на крайния срок. Ако  обаче се получи забавяне в изпълнението на дейност, която влиза в състава на  критичния път, то с толкова ще се забави и цялото изпълнение на комплекса.  Затова именно дейностите, които влизат в критичния път, са подложени на  наблюдение. <br />
  <img src="images/metods dyn_image008.jpg" alt="8" width="361" height="129" /><br clear="all" />
              Да разгледаме следната  мрежа, в която отделните групи възли са разделени етапи. Да приемем,  че във всеки етап има не повече от <em>п </em>възли. Ако търсим критичен път чрез  преравяне на всички възможни пътища от началото до края, то трябва да  генерираме всичките <em>nМ </em>варианти.  Ако използваме метода на динамичното програмиране, задачата, както ще видим, ще  се реши със сложност <em>O(Mn2). </em><br />
                Да  въведем номерация на възлите от 1 до общия им брой <em>N</em><em>. </em>Номерацията  бъде <em>правилна, </em>ако при ребро &lt; <em>i,j </em>&gt; имаме <em>i</em>&lt; <em>j. </em>Тогава началният възел, в който  няма входящи ребра, ще има номер 1, а крайният, от който няма изходящи ребра,  ще има номер <em>N. </em>Нека <em>Т </em>={<em>tij</em>}  е матрица, елементът <em>tij</em>определя  времето за изпълнение на дейността, представена с ребро &lt;<em>i,j</em>&gt;.  Нека <em>j </em>е кой да е възел  в мрежата. Да дефинираме функция <em>w(j), </em>представяща дължината на  най-дългия път от възел <em>j </em>до  последния възел на мрежата <em>N. </em>Следвайки  свойствата, посочени по-горе на задача, за която е в сила принципът за  оптималност, се вижда, че<br />
                <img src="images/metods dyn_image010.gif" alt="10" width="195" height="22" /><em>,</em><br />
                където Q<em>j</em> е множеството от възли -  наследници на <em>j</em>-тия възел (т.е. те са всички възможни  състояния на следващия етап). Така получихме една рекурентна формула, от която  личи, че за да се определи <em>w(j), </em>трябва да се вече известни стойностите й за възлите, наследници на <em>j</em>-тия възел. Като за всяка рекурентна формула,  трябва да е зададена и начална стойност, която в този случай очевидно е <em>w</em>(<em>N</em>)=0.Благодарение на принципа за  оптималност получихме рекурентната формула. С нейна помощ алгоритъмът за  решение на задачата, която в тази формулировка е да намерим w(l), ще се запише  леко, като се започне отзад напред. Поради правилната номерация, при  определянето на <em>w(j), </em>вече ще са определени стойностите на <em>w</em> за  наследниците на възела <em>j, </em>които  са с номера големи от <em>j. </em>Преди  описанието на самия алгоритъм за изчисление на функцията <em>w</em>(l), която ще даде само дължината на критичния път, ясно е, че  трябва потърсим начин да се идентифицират и дейностите, които го съставят, т.е.  да се съхранят и възлите, през които критичният път преминава. Това може  направим, ако с всеки възел <em>j </em>свържем елемент от масив <em>ind, </em>който  посочва номера на възел <em>k, </em>през който се постига максимумът от формула  (1). <br />
  </p>
              <p><em>алгоритъм Schеdиlе  _Network </em><br />
                <em><u>за</u></em> i:= 1 <em><u>до</u></em><em> N <u>прави</u></em><br />
                <em>w</em>[<em>i</em>] :=0; <br />
                <em><u>за</u></em><em> j:= N</em><em>-</em>1 <em><u>със  стъпка</u></em><em><u> </u></em>-1 <em><u>до</u></em><em> 1 <u>прави </u></em><em><u> </u></em><br />
                <em><u>за</u></em><em> k:= j </em>+1 <em><u>до</u></em><em> N <u>прави</u></em><br />
                <em><u>ако</u></em><em> Т[j,k]&#8800;</em><em>0  </em><em>аnd</em><em>Т[j,k]</em><em>+</em><em> w[</em><em>k]</em>&gt; <em>w</em>[<em>j</em>] <em><u>то</u></em><em><u> </u></em><br />
                <em>w</em>[<em>j</em>]:= <em>T[j,k]+ </em><em>w[</em><em>k]; </em><br />
                <em>ind[j]:=k;</em></p>
              <p><br />
                Лесно може да се направи оценка  за сложност на описания алгоритъм. В него има  два вложени един в друг цикъла, броят на повторенията на телата на които зависи  от броя на ребрата. Така се получава оценка <em>O(N2).</em>Ако в мрежовия график има ясно изразени <em>М </em>етапа, всеки от  които има не повече от <em>п </em>възела, то оценката за сложност получава вида О(<em>Мn2). </em>Вижда се, че прилагането на динамичното програмиране драстично намалява  сложността на алгоритъма за решение задачата. <br />
                Извеждането на решението:  дължината <em>w</em>(l) и възлите от критичния  път става лесно със следния алгоритъм: <br />
                <em>nечат</em>(<em>w</em>[1]); <em>i</em>:= 1; <br />
                <em><u>докато</u></em>  <em>i</em> &lt; <em>N <u>прави</u></em><br />
                <em>nечат(i); i:=ind[i]; </em><br />
                Следната горна триъгълна матрица  представя ненулевите елементи на матрицата за един конкретен пример: <br />
                <img src="images/metods dyn_image012.gif" alt="12" width="213" height="216" /> <br />
                <img src="images/metods dyn_image014.jpg" alt="14" width="333" height="116" /><br clear="all" />
                </p>
              <p>След  приложението на описания алгоритъм, на следната фигура е показано решението на  задачата за този случай: към всеки възел е представена двойка ­стойността на  критичния път до последния възел и номера на възела, през който този критичен  път минава. <br />
                Да обърнем внимание на  основните моменти в приложението на метода на <br />
                динамичното програмиране: </p>
              <ol>
                <li>решението на задачата може да се представи като  последователност от решенията на подходящо формулирани подзадачи; </li>
                <li>за тази последователност е в сила принципът за  оптималност; </li>
                <li>решенията на отделните етапи могат да се свържат със  съответна рекурентна формула. </li>
              </ol>
              <p>Да разгледаме следната <u>задача</u>.[З]<br />
                Зададени са монети със стойности <em>v1,  v2, .,vn</em> цели положителни числа, като<em> v1&lt;v2&lt;.&lt;v</em><em>n</em>. Броят монети от всяка от  стойностите е неограничен. Зададено е и цялото положително число <em>Х</em>. Да се намери минималният брой монети, сумата от  стойностите на които е равна на <em>X</em><em> . </em><br />
                Ще отбележим, че алгоритъм с избор на максималния  възможен брой монети със стойност <em>vn</em>след това -  с <em>vn-1</em> до  изчерпване на <em>Х, </em>не е верен.  Наистина, ако <em>Х=89 </em>и (<em>v</em><em>1</em><em>v2,v</em><em>3</em>)=(1,40,50),  то <em>Х</em>=1*50+З9*1 (с 40 монети), а  оптималното решение е <em>Х </em>= 2 * 40 + 9 * 1  (с 11 монети). <br />
                Нека <em>В</em><em>(</em><em>Y</em><em>) </em>е броят монети, необходими за формиране на сума <em>Y</em><em>. </em>Решение на нашата задача е <em>В(Х). </em>За определянето  на <em>В(Х) </em>последователно ще намерим <em>В(</em><em>0</em><em>),В(</em><em>1</em><em>), ... ,В(Х </em>-1).  Очевидно, <em>В(</em><em>0</em><em>)</em>= 0. Ако в оптималното представяне на сума<em> Y</em>, 1 &#8804; <em>Y </em>&#8804; <em>X</em> от <em>В(</em><em>Y</em><em>) </em>монети участва например монета със стойност <em>vi</em> (<em>Y</em> <em>- vi </em>&#8805; 0), то сумата <em>Y</em>- <em>v, </em>може да се представи с <em>В(</em><em>Y</em><em>)-1 </em>монети. Следователно <em>В(</em><em>Y</em><em>)-1&#8805; </em><em>В(</em><em>Y</em> <em>- vi). </em>От друга страна, сумата <em>Y </em>може да се  представи с   <br />
  <em>В(</em><em>Y - vi</em>) монети (за Y- <em>v</em><em>i</em><em>) </em>и добавяне на една монета със  стойност <em>v</em><em>i</em><em>, </em>т.е. <em>В(</em><em>Y</em><em>) &#8804;</em><em>В(</em><em>Y</em> <em>- vi)+1. </em>Последните две неравенства водят до <em>В(</em><em>Y</em><em>) = </em><em>В(</em><em>Y</em> <em>- vi)+1. </em>Така достигаме до <br />
                (2) <img src="images/metods dyn_image016.gif" alt="16" width="362" height="19" /><br />
                с начално условие <em>В</em>(0) = 0. <br />
                Задачата за определяне на <em>В(</em><em>Y</em><em>) </em>не винаги има решение. Например за <em>Х </em>= 2 и  (<em>v1, v2, v</em><em>3</em>)= (5,40,50). В такъв случай ще считаме <em>В(</em><em>Y</em><em>)=mах_Х </em>(достатъчно голямо цяло число). <br />
                Заедно с това да определим минималния брой монети <em>В(</em><em>Y</em><em>) </em>за всяка сума <em>Y</em><em>, </em>трябва да знаем и чрез кои точно монети се постига този  минимален брой. Затова в последователните стъпки за определяне на <em>В(1),В(2),  ... ,В(Х) </em>трябва да определим и чрез коя сума <em>Y</em><em>-v</em><em>i</em>и чрез прибавяне на коя монета <em>v</em><em>i</em>се постига минимумът на всяка стъпка. Затова при  изчисляването на всяко <em>В(Y), </em>в <em>d(Y) </em>ще съхраним и номера <em>i </em>на монетата, с която се постига  минимумът. </p>
              <p><br />
                <em>алгоритъм  sит Х; </em><br />
                <em>В[</em><em>0</em><em>]:=</em><em>0</em><em>;        </em><br />
                <em><u>за</u></em><em>Y</em><em>:=1 <u>до</u> Х <u>прави</u></em><em><u> </u></em><br />
                <em>В[</em><em>Y</em><em>]:= </em>mах_<em>Х</em>; <br />
                <em><u>за</u></em> <em>i</em>:= 1 <em><u>до</u></em><em> n <u>прави</u></em><br />
                <em><u>ако</u></em><em>Y</em>- <em>v</em>[<em>i</em>] &#8805; 0 <em>and В[</em><em>Y</em>- <em>v</em>[<em>i</em>]]+1 &lt; <em>В[</em><em>Y</em><em>] <u>то</u> </em><br />
                <em>В[</em><em>Y</em><em>] :=В[</em><em>Y</em>-<em>v</em>[<em>i</em>]]+1; <em>d[Y]:= </em><em>i</em>; <br />
                След  определянето на <em>В(Х) </em>решението на задачата се извежда със: <br />
                <em><u>ако</u></em><em>В[Х] </em>= mах_<em>Х</em> <em><u>то</u></em><br />
                <em>nечат('задачата  няма решение); </em><br />
                <em><u>иначе</u></em><br />
                <em>печат</em><em>(</em><em>'минимапен брой монети', В(Х)); </em><em>Y</em><em>:=Х; </em><br />
                <em><u>повтаряй</u></em><br />
                <em>печат</em><em>(</em><em>'монета', v[d[i]]); У:= У  -v[d[i]]; </em><br />
                <em><u>докато</u></em><em>Y</em><em>=</em><em>0</em><em>; </em></p>
              <p><br />
                <u>Задача за най-дълга обща подредица  [4] </u><br />
                Това е  още една задача за приложение на метода на динамичното програмиране. Решаването  й се основава на следната идея: дефинираме реурсивен алгоритъм, който може и да  е неефективен, тъй като извиква себе си за определен брой подзадачи. След това  го преобразуваме в итеративен, като решението на всяка подзадача се съхранява в  подходяща таблица още първия път се изчисли; след това тези решения се  използват вместо да се преизчисляват. <br />
                Задачата се формулира така: зададени са две редици <em>Х=</em>{<em>x1, x2,.,xm</em>}и<em>Y=</em>{<em>y1,y2,.yn</em>}<em>. </em>Елементите  на тези редици могат да бъдат цели числа, символи н. За конкретното разглеждане  ще приемем, че <em>Х </em>и <em>Y</em>са низове от символи. Tърси се дължината и съставът на  най-дългата подредица на двата низа.(Подредица на редицата <em>Х=</em>{<em>x1, x2,.,xm</em>}е всяка редица <em>xi1,  xi2,.,xik</em> такава, че <em>ij &lt; ij+1</em>  т.е.  това е редица от елементи на <em>Х, </em>не  непременно съседни, но все пак и по  реда им в <em>Х). </em><br />
                Поставената  задача не е самоцелна. Тя възниква например в молекулярната биология. ДНК  редицата (геномът) може да се представи като низ от четири символа <em>ACGT, </em>съответстващи  на четирите подмолекули формиращи ДНК. Когато имат  две такива редици, биолозите искат да знаят колко те си приличат. Един начин за  определяне на прилика между двете редици е да се намери дължината на тяхната най-дълга обща подредица (НОП).<br />
                Решение  на задачата. Оказва се, че вместо да търсим директно най-дългата подредица,  по-леко е определянето на нейната дължина. Може да отбележим общите свойства на  НОП<em>: </em><br />
                Нека <em>Z </em>={<em>z1, z2,. zk</em> }е  коя да е НОПна <em>Х </em>и <em>Y</em><em>. </em>Тогава <br />
                1.  Ако <em>xm</em><em> =</em><em> yn</em>то<em>zk</em><em>=</em><em> xm</em><em> =</em><em> yn</em>и{<em>z1, z2,. zk-1</em>}е  НОПна {<em>x1, x2,.,xm-1</em>}и {<em>y1,y2,.yn-1</em>}<em>. </em>Наистина,  ако <em>zk </em>&#8800; <em>xm</em>то всяка редица <em>Z</em>, която не завършва с <em>xm</em><em> =</em><em> yn</em>може да бъде направена по-дълга с  добавяне на <em>xm</em><em> =</em><em> yn</em>в края й. Но тогава Z няма да е НОП<em>. </em>Затова НОП<em>Z</em> трябва да завършва с  <em>xm</em><em> =</em><em> yn</em><em>. </em>Редицата  {<em>z1, z2,. zk-1</em>}е  НОПна {<em>x1, x2,.,xm-1</em>}и {<em>y1,y2,.yn-1</em>}, тъй като няма по-дълга ОПна двете редици, иначе Z  няма да е НОПна <em>Х </em>и <em>Y</em><em>. </em><br />
                2.  Ако <em>xm </em>&#8800;   <em>yn</em>и съответно <em>zk</em>&#8800;<em>  xm,</em>,то Z е НОП на {<em>x1,  x2,., xm-1</em>} и <em>Y</em> и няма по-дълга ОП на {<em>x1, x2,., xm-1</em>} и <em>Y</em>, иначе Z няма да е НОПна <em>Х </em>и <em>Y</em><em>.</em><br />
                Аналогично,  ако <em>zk</em>&#8800;<em>  yn</em> , то Z е НОПна <em>Z</em>и {<em>y1,y2,.yn-1</em>}<em>.</em> <br />
                Тези  разсъждения водят към следната рекурсивна функция за <em>L(i,j) </em>- дължината НОП на низовете {<em>x1, x2,.,xi</em>}и {<em>y1,y2,.yj</em>}<em>.</em><br />
                <em>функция  L(i,</em><em>j) </em><br />
                <em><u>ако</u></em><em>i = </em><em>0</em><em> or j = </em><em>0</em><em><u>то</u></em><br />
                <em>L:=</em><em>0</em><em>; </em><br />
                <em><u>иначе  ако</u></em><em>X[i]  = </em><em>Y</em><em>[j]  то</em><br />
                <em>L  :=L(i -1,</em><em>j</em><em> -1</em><em>)+1</em><br />
                <em><u>иначе</u></em><br />
                <em>L:=  max{L(i,j -1),L(i -</em><em>1</em><em>,j)} </em><br />
                Обръщението  към функцията <em>L</em> за НОП на <em>Х</em> и <em>Y</em> ще бъде <em>L</em>(<em>m</em>, <em>n</em>).</p>
              <p> <br />
                По-горният алгоритъм  дава коректно решение на задачата, но изисква много време. Например, ако двете  редици <em>Х</em> и <em>Y</em> нямат обща подредица, ще се изпълнява винаги последният ред с две рекурсивни  извиквания, което при  <em>m</em>= <em>n</em> води до операции от порядъка на 2<em>n</em>. Затова, както и в предишните задачи, ще използваме  рекурсивната дефиниция на <em>L(i, j)</em> като основа за преобразуването на алгоритъма в итеративен, който започва изчислението  от тривиалния случай. Сега вместо функция <em>L(i,  j)</em> ще използваме масив <em>L[i, j]</em>, в  който ще съхраняваме изчислените резултати от подзадачите. Вместо две  рекурсивни извиквания ще използваме два вложени един в друг цикъла.  Единствената грижа в организацията им е елементите <em>L[i -1,j-1]</em>, <em>L[i-1, j]</em>, <em>L[i, j-1]</em> да бъдат изчислени преди изчисляването  на <em>L[i, j]</em>. Тривиалният случай  изисква разширение на масива <em>L</em> с един  нулев ред и една нулева колона, инициализирани със стартовите стойности 0. <br />
                Разбира се, полезно е  освен намирането на дължината на НОП,  още и намирането на елементите на самата НОП.  С оглед на това ще въведем един символен масив <em>D</em>, чийто елемент <em>D[i,j]</em> сочи посоката, от която е изчислена стойността <em>L[i, j]:</em> <br />
                <em>'d'  - от диагонала L[i -1,</em><em>j</em><em> -1];</em><br />
                <em>'</em><em>u</em><em>' - от горния ред; </em><br />
                <em>'</em><em>l</em><em>' - от левия стълб. </em><br />
                </p>
              <p>Следният  итеративен алгоритъм реализира описаната идея: <br />
                <em>алгоритъм  LCS </em><br />
                <em>{инициализация  на L} </em><br />
                <em><u>за</u></em><em><u> </u></em><em>i:= </em><em>0 </em><em><u>до</u></em><em>т</em><em> <u>прави</u></em><em>L[i,</em><em>0</em><em>]:= </em><em>0</em><em>; </em><br />
                <em><u>за</u></em><em>j  &gt; 1 <u>до</u> п <u>прави</u></em><em>L[</em><em>0</em><em>,</em><em>j</em><em>]:= </em><em>0</em><em>;</em><br />
                <em> {итерации за L} </em><br />
                <em><u>за</u></em><em>i:= </em><em>0</em><em><u>до</u></em><em> т <u>прави</u></em><br />
                <em><u>за</u></em><em>j:=  1 <u>до</u> п <u>прави</u></em><br />
                <em><u>ако</u></em><em>X[i]  = У[j] то</em><br />
                <em>L[i,j]:=  1 + L[i -1,</em><em>j</em><em> -1]; </em><br />
                <em>D[i,j]:=  'd'; </em><br />
                <em><u>иначе</u></em><br />
                <em>t</em><em>:= L[i -1,</em><em>j]</em><em>; D[i,j]:= 'и'; </em><br />
                <em><u>ако</u></em><em> L[i,j -1] &gt; t <u>то</u></em><br />
                <em>t</em><em>:= L[i,j -1]; D[i,j]:= '</em><em>l</em><em>'; </em><br />
                <em>L[i,j]:= </em><em>t</em><em>; </em><br />
                </p>
              <p>След изпълнение на алгоритъма,  дължината на НAП  се намира в елемента <em>L[</em><em>т,n]. </em>Отпечатването на  състава на самата НAП  може да стане със следната рекурсивна процедура. <br />
                <em>алгоритъм prn _LCS(i,j); </em><br />
                <em><u>ако</u></em><em> i</em> &gt;  О <em>and j </em>&gt;0 <em><u>то</u></em><br />
                <em><u>вариант от</u></em><em> D[i,j]: </em><br />
                <em>'d': prn_LCS(i -1,</em><em>j-</em>1); <em>nечат(Х[i]); </em><br />
                <em>'и': рrn _LCS(i -1,</em><em>j)</em><em>; </em><br />
                <em>'</em><em>l</em><em>': prn_LCS(i,j </em>- 1); <br />
                <em><u>край на вариант;</u></em><em><u> </u></em><br />
                с обръщение <em>prn_LCS(m,n). </em><br />
                </p>
              <p>Сложността  на предложения итеративен алгоритъм <em>LCS, </em>както се вижда от двата вложени  един в друг цикъла, е <em>О(тn). </em>Недостатък на подхода на динамичното  програмиране е, че като се избягва рекурсията, която изисква много време, се  въвежда итеративно изпълнение, което изисква много памет - таблицата <em>L[i</em><em>,</em><em> j</em><em>].</em></p>
      </div>
       <a style="display:scroll;position:fixed;bottom:10px;right:10px;" href="#" title="В началото"><img width="30" height="30" src="images/button.png"/></a>  
</div>
	
<div id="footer">
			<p>&copy; Copyright Synthesis and Analysis of Algorithms &middot; 2017 &middot; Design: Elitsa Nikolova&middot; 
			 
			  <a href="index.html"><span>Алгоритми</span></a>&middot;
              <a href="struct.html"><span>Структури данни</span></a>&middot;
               <a href="metods.html"><span>Методи за създаване</span></a>&middot;
               <a href="sort.html"><span>Алгоритми за сортиране</span></a>&middot;
		    <a href="map.html"><span>Карта на сайта</span></a></p>
</div>
</body>
</html>