<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-5" />
	<meta name="Author" content="Elitsa Nikolova" />
	<meta name="Robots" content="index,follow" />
	<meta name="Description" content="Synthesis and Analysis of Algorithms" />
	<meta name="Keywords" content="Synthesis,Analysis,Algorithms" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<title>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</title>
    <style type="text/css">
<!--
.style1 {
	font-size: 1.2em;
	color: #333333;
}
.style7 {font-size: 1.2em}
.style13 {font-size: 0.7em}
-->
    </style>
</head>
<body>
	<div id="main">
<ul id="menu">
<li><a href="sort.html"><span class="key">Алгоритми за сортиране</span></a></li>
            <li><a href="metods.html"><span class="key">Методи за създаване</span></a></li>
            <li><a href="struct.html"><span class="key">Структури данни</span></a></li>
            <li><a href="struct.html"><span class="key">Алгоритми</span></a></li>
</ul>
		
  <div id="intro_left">
			<p>Алгоритмите в сайта са описани на псевдокод, което ги прави по-лесни за четене и разбиране.</p>
	  </div>
		
		<div id="intro_right">
			<p class="white">УЕБ БАЗИРАНО ПРИЛОЖЕНИЕ ПО</p>
		  <h1>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</h1>
			<p></p>
		</div>

	  <ul id="menu_left">
		<li><a href="metods private.html"><span>Метод на частните цели</span></a></li>
		<li><a href="metods evristic.html"><span>Евристични алгоритми</span></a></li>
		<li><a href="metods search.html"><span>Изчерпващо търсене с възврат</span></a></li>
        <li><a href="metods dyn.html"><span>Метод на динамичното програмиране</span></a></li>
		<li><a href="task03.html"><span>Задачи</span></a></li>
	  </ul>


			<div class="special">
			  <h1> Евристични алгоритми </h1>
			  <p>Една голяма част от задачите, подлежащи на компютърно  решение са така речените <em>комбинаторни задачи. </em>Това са задачи, в които от  едно крайно множество от елементи трябва да се избере един или повече елементи,  които притежават някакво свойство. Проблемът в такива задачи е, че въпреки че множеството  е крайно, обикновено то е с голяма мощност, т.е. има голям брой елементи, и  генерирането и анализът на всеки елемент изисква време. <br />
			    Такава  например е задачата на търговския пътник (trаvеlling sаlеsmаn problem, TSP). Множеството на всички маршрути е крайно, но както  видяхме, с нарастването  на <em>n </em>техният брой <em>(n </em>-1)! расте  много бързо. Изчерпващият алгоритъм, който разгледахме, решава правилно  задачата, като намира цените на всички възможни маршрути, и от тях избира  най-евтиния. Този алгоритъм обаче е неизползваем при големи стойности на <em>п . </em><br />
			    Евристиките,  или евристичните алгоритми, имат това свойство, че решават задачата, като  намират &quot;добро&quot; решение, не непременно най-доброто, за приемливо  време. <br />
			    Не  съществува универсална структура на евристичен алгоритъм. Един подход към  намиране на евристичен алгоритъм е да разделим условията на задачата на два  класа: </p>
			  <ol>
			    <li>задължителни  условия (по-леки за удовлетворяване); </li>
			    <li>условия,  относно които може да се направи компромис (по-трудни за удовлетворяване). </li>
		      </ol>
			  <p>Видяхме,  че изчерпващият алгоритъм решава правилно задачата, но не дава решение за  приемливо време. За да прибегнем към построяването на евристичен алгоритъм, да  разделим условията на задачата на следните два класа: </p>
			  <ol>
			    <li>да се построи маршрут, който  минава през всяко населено място по веднъж; </li>
			    <li>построеният маршрут да бъде  най-евтин от всички възможни. </li>
		      </ol>
			  <p>Условие 1 ще бъде задължително за  изпълнение, а по отношение на условие 2 може да се допусне компромис. В  случая задачата позволява това, ако разсъждаваме така: след като за приемливо  време не можем да получим <em>точното</em> решение  - най-евтиния маршрут - да опитаме за <em>приемливо </em>време да получим <em>приемлив </em>маршрут (например не най-скъпия), което да бъде приближение на точното  решение. <br />
			    Обикновено  евристиките (от &quot;еврика&quot; - открих) се градят на <em>аналогия</em> с някоя друга  задача. В нашия случай задачата, по аналогия с която ще търсим евристика, е  тази за намиране на глобален минимум, ползвайки само локална информация.  Например, ако трябва да определим най-ниската точка от релефа на дадена област,  намирайки се в точка (*). От това място имаме само локална информация за  релефа, това което е видимо до най-близките върхове. Без да имаме глобална  информация (за релефа зад върховете), можем да определим минимум точка (.),  което е само приближение към действителния минимум, но е по-добро от някои от  максимумите. <br />
			    За да намерим приближение на  най-добрия маршрут на задачата на тьрговския пътник, може да разсъждаваме  аналогично. Намирайки се в началния пункт, нямаме глобална информация за цените  на всички маршрути, но може да използваме локална информация: цените на  преходите до непосредствените съседи на началния пункт; стремейки се все пак  към приемлива цена, да изберем като следващо населено място най-близкия съсед.  Преминавайки в него, се намираме се в същата ситуация: да преминем към  най-близкия съсед, без да се връщаме във вече посетено населено място.  Следователно, за да удовлетворим условие 1 да се посети всяко населено място  точно по веднъж, трябва да се погрижим местата, които вече са били посетени, да  бъдат маркирани като такива. Остава <em>n</em>-1 пъти да се повтори описаната  стъпка на избор на най-близкия непосетен съсед на текущото населено място. След  последното посетено населено място остава да се направи връщане в отправния  пункт. В следващото описание на алгоритъма ще оставим началния пункт като  параметър <em>U </em>с оглед на следваща  модификация. <br />
  </p>
			  <p><em>алгоритъм TSP1 (</em><em>U</em><em>, </em>C, <em>tour</em><em>,  cost) </em><br />
			    {    С: <em>матрица N </em>х <em>N </em>с <em>цените на преходите, симетрична в общия случай, </em><em>cii=0</em><br />
                <em>tоиr: поредица от ребра (и, </em><em>v</em>) <em>на маршрута </em><br />
                <em>cost: цена на маршрута} </em><br />
                <em>инициализация:  tоиr:= </em>{ }; <em>cost </em>:= О; <em>V </em>:= <em>U</em><em>; </em><br />
                <em>маркиране на всички пунктове като  неизползвани;</em><br />
                <em> маркиране на U като използван; </em><br />
                <em><u>за</u></em><em>k:=1 </em><em><u>до</u></em><em> п </em>-1 <em><u>прави</u></em><br />
                <em>определяне на W, C(V, W) </em>= <em>min от възможните; </em><br />
                <em>cost:= cost </em>+ <em>C(V,W); </em><br />
                <em>tоиr </em>:= <em>tоиr </em>+ <em>(V, W); </em><br />
                <em>маркиране на W като използван; </em><br />
                <em>V:=W; </em><br />
                <em>затваряне: tоиr:= tоиr +(V,U);  cost:= cost+C(V,U); </em><br />
		      </p>
			  <p>Идеята на алгоритъма: на всяка  стъпка се поставят частни цели, които водят към поредица от локални минимуми;  ясно е обаче, че тази поредица не гарантира глобалния минимум. Това се видя и  от примера в Глава 1. Построеният маршрут удовлетворява условия 1 и прави опит  за намиране на добро решение относно условия 2, но не непременно най-доброто. <br />
			    Една  следваща стъпка на детайлизация, с изясняване на механизма за маркиране и  съхранение на елементите на маршрута, може да изглежда така: <br />
                <em>алгоритъм TSP1 (</em><em>U</em><em>, </em>C, <em>tour</em><em>,  cost) </em><br />
			    {      С: <em>матрица N </em>х <em>N </em>с <em>цените на преходите, симетрична в  общия случай, </em><em>cii=0</em><br />
                <em>tou</em><em>r: масив от поредните възли на  маршрута </em><br />
                <em>cost: цена на маршрута} </em><br />
                <em>инициализация: tоиr</em><em>[1</em><em>]:= </em><em>U</em><em>; cost:= </em>О; <em>V:= </em><em>U</em><em>; </em><br />
                <em><u>за</u></em><em> k:=</em><em>1 </em> <em><u>до</u></em><em> п <u>прави</u> mark[i]:= trие; </em><br />
                <em>mark[V] </em>:= <em>false; </em><br />
                <em><u>за</u></em><em> k:=</em><em>1</em> <em><u>до</u></em><em> n-1 </em><em><u>прави</u></em><br />
                <em>ст:=&#8734;; </em><br />
                <em><u>за</u></em> <em>i</em>:=1 <em><u>до</u></em><em> п <u>прави</u></em><br />
                <em><u>ако</u></em><em> mark[i] and C[V,i] </em>&lt; <em>ст <u>то</u></em><br />
                <em>W:= </em><em>i</em>; <em>ст:=  C[V,i]; </em><br />
                <em>cost:= cost </em>+ <em>C(V,W); </em><br />
                <em>tоиr[k </em>+ 1]:= <em>W; </em><br />
                <em>mark[W]:= false; </em><br />
                <em>V:=W; </em><br />
                <em>затваряне: tоиr[n+</em><em>1</em><em>] :=U; cost :=cost +C(</em><em>V,U</em><em>);</em></p>
			  <p><u>Оценка за сложност </u></p>
			  <ol>
			    <li>Кой да е алгоритъм за решение на  задачата ще изисква въвеждане на данните. За симетрична матрица С това са  елементите над (или под) главния диагонал, чийто брой е </li>
		      </ol>
			  <p><img src="images/metods evristic_image002.gif" alt="2" width="221" height="28" />Следователно само сложността на  въвеждане е О(<em>n2). </em><br />
			    2.  Самият алгоритъм <em>TSP</em>1предполага <em>п</em>-1 изпълнения на тялото на  цикъла по <em>k; </em>във всяка стъпка от него се търси минимум измежду най-много<em> п</em> елемента, т.е. отново имаме сложност О(<em>n2). </em><br />
			    Общо, сложността е О(<em>n2), </em>което показва, че това е най-доброто, което за тази задача може да се постигне. <br />
  <u>Пример</u>: Да се проиграе алгоритъмът <em>TSP</em>1за задачата при следните  данни: <em>n</em>=5 и <br />
  <img src="images/metods evristic_image004.jpg" alt="4" width="190" height="155" />&nbsp;</p>
			  <br clear="all" />
			  <br />
              <img src="images/metods evristic_image006.gif" alt="6" width="147" height="120" />
              <p>&nbsp;</p>
              <p>Тръгвайки от начален пункт 1, алгоритъмът <em>TSP</em>1дава  решение (1- 2 - 5 - 3 - 4 -1) c <em>cost</em>=14; оптималното решение с тези данни, например  получено с изчерпващ алгоритъм, е (1-5-3-4-2-1)  с <em>cost=13. </em>Но има и много по-лоши решения, например полученото с  търсене не на най-близкия, а на най-далечния съсед: (1-4-2-3-5-1) с <em>cost=22. </em><br />
                Недостатъкът  на алгоритъма <em>TSP</em>1<em>, </em>който  се вижда при проиграването му върху този пример, е, че в началото се избират  малките стойности на <em>С</em><em>ij</em><em>, </em>а  за края, когато вече няма избор, остават големите. Това в известен смисъл се  влияе от началния пункт. Да отбележим това, че един маршрут представлява <em>затворена </em>начупена линия, минаваща през всички възли; следователно можем да изберем  за начален кой да е възел от нея и ще имаме маршрут със същата цена. Тогава, за  да се освободим от влиянието на началния възел върху цената на постигнатия  маршрут, може да построим модификация на алгоритъма в следния смисъл: да  определим решения, получени с <em>TSP</em>1при  начален пункт, избиран от едно зададено множество <em>{U1,U2,</em><em>.</em><em>,Up}, </em>в  крайния вариант - от всички възли. От получените решения да изберем  най-доброто. Да отбележим, че това пак не са всички възможни маршрути,  следователно пак няма гаранция за избор на най­-добро решение. <br />
  <em>алгоритъм TSPM(n, C,cmin,tmin); </em><br />
  <em>инициализация: cmin:= </em>&#8734;; <em>tmin </em>:= { }; <br />
  <u>за</u><em>j:= </em>1 <em><u>до</u></em><em> п <u>прави</u></em><br />
  <em>TSP</em>1<em>(j,</em>С, <em>соst,tоиr); </em><br />
  <em><u>ако</u></em><em> cost </em>&lt; <em>cmin <u>то</u></em><br />
  <em>cmin:= cost; tmin:= tоиr; </em><br />
                Сложността на този алгоритъм се  определя от това, че <em>п </em>пъти се изпълнява алгоритъмът <em>TSP</em>1със сложност О(<em>n2). </em>Следователно  сложността на <em>TSPM </em>е О(<em>n3). </em>отново по-добра от О(<em>n!)</em>на  изчерпващия алгоритъм. Между другото, последният алгоритъм ще намери най-доброто  решение на задачата от фиг.3 на Глава 1, като започне от начален пункт  най-лявата или най-дясната точка. <br />
  <u>Забележка</u>: В двата алгоритъма <em>TSP</em>1и <em>TSPM </em>при  инициализацията за търсене на минимум се използва &quot;&#8734;&quot;, т.е. много голямо число. Ролята на такова  число може да играе величината <br />
  <img src="images/metods evristic_image008.gif" alt="8" width="127" height="56" /> </p>
              <p>получена още при въвеждане на  данните за матрицата С. Цената на кой да е маршрут ще е по-малка от <em>c</em>inf, тъй като ще съдържа само някои  от елементите на матрицата С.</p>
              <p><u>Задача за съставяне на разписания </u><br />
                Зададени са <em>т </em>задания <em>Lj, </em>всяко от които изисква за  изпълнението си време <em>tj; </em>разполагаме с <em>п </em>еднотипни процесора <em>Pi</em>. Задачата има смисъл при <em>m</em><img src="images/metods evristic_image010.gif" alt="10" width="14" height="19" /><em>n</em>. Предполага  се, че процесорите работят паралелно и независимо; всяко задание се изчаква да  завърши докрай; при завършване се зарежда ново задание, като зареждането не  отнема време. Целта е да се направи такова разписание на зареждане на заданията  по процесорите, че общото време за завършване на всички задания да е минимално. <br />
                Тъй като времето за зареждане се  приема за нулево и процесорите са еднотипни, т.е. на кой процесор се изпълнява  дадено задание няма значение, то между разписанията и различните пермутации от  задания <em>Lj </em>има  взаимно еднозначно съответствие: <br />
                на  всяко разписание съответства една пермутация; <br />
                на всяка  пермутация съответства едно разписание. <br />
                Следователно  общият брой разписания съвпада с броя на пермутациите на заданията <em>m!,</em> при положение, че всички времена <em>tj</em>са различни. Ако някои отвремената съвпадат, някои от  пермутациите ще са неразличими. Важното е, че един изчерпващ алгоритъм трябва  да генерира всички <em>m!</em>разписания, да  изчисли общото време на завършване на всички задания при съответното  разписание, и да намери най-малкото такова време. Явно такъв алгоритъм ще има  сложност О(<em>m!</em><em>)</em> <br />
                Целта  отново е да построим евристичен алгоритъм, който за приемливо време да построи  приемливо решение. За да стигнем до някаква евристика, т.е. досещане, върху  която да построим такъв алгоритъм, да разгледаме една конкретна задача. Нека  имаме три процесора -P1, P2, P3 - и шест задания с времена: <br />
                t1=5, t2=5, t3=2, t4=1,  t5=1, t6=8<br />
                и да разгледаме разписанието,  съответстващо на пермутацията t1, t2, t3, t4,  t5, t6. Върху  оси, съответстващи на времето на всеки от трите процесора, може да отбелязваме  зареждането, изпълнението и завършването на всяко задание според разписанието: </p>
              <p align="center"><img src="images/metods evristic_image012.gif" alt="12" width="423" height="144" /> </p>
              <p>Горното  разписание се реализира, като започва зареждането на едно по едно на първите  три задания; щом се освободи процесор и има още задания в опашката, поредното  от тях се зарежда. Общото време, в което всички задания са приключили за това  разписание, както се вижда, е <em>Т </em>= 12 единици  време. Целта на задачата е да намерим такова разписание, при което времето <em>Т </em>е минимално. <br />
                От проиграването на това разписание се вижда, че  недостатъкът му се изразява в това, че най-дългото задание се зарежда последно,  и макар че всички други са завършили, изчаква се завършването на най-дългото.  Тогава, ако най­-дългото задание се зареди първо, Т.е. е първо в редицата, то  този недостатък ще се избегне; за останалите очевидно ще важи същото, т.е.  най-дългото от останалите да е на второ място и т.н. Така стигаме до следната <em>евристика: </em>да се избере онази пермутация, в която заданията са сортирани в низходящ  ред по времената им. За конкретната задача това е пермутацията t6, t1,  t2, t3, t4, t5. Тогава  симулацията на изпълнението на това разписание е: <br />
  <img src="images/metods evristic_image014.gif" alt="14" width="495" height="147" /> <br />
                Постигнатото сега време е <em>Т </em>= 8, което за тази задача е и най-доброто,  защото предварително е ясно, че <br />
  <img src="images/metods evristic_image016.gif" alt="16" width="104" height="27" /><br />
                При приложената евристика  условията на задачата се удовлетворяват в следния вид: </p>
              <ol>
                <li>Всички  задания се изпълняват (задължителни условия); </li>
                <li>По  възможност за малко време (компромисно условие) </li>
              </ol>
              <p>Сложността  на алгоритъма с предложената евристика, заради сортирането, е О(<em>m2</em>) ако не се използва ускорен алгоритъм за  сортиране. </p>
              <h1>&nbsp;</h1>
	  </div>
	   <a style="display:scroll;position:fixed;bottom:10px;right:10px;" href="#" title="В началото"><img width="30" height="30" src="images/button.png"/></a>  
</div>
	
<div id="footer">
			<p>&copy; Copyright Synthesis and Analysis of Algorithms &middot; 2017 &middot; Design: Elitsa Nikolova&middot; 
			 
			  <a href="index.html"><span>Алгоритми</span></a>&middot;
              <a href="struct.html"><span>Структури данни</span></a>&middot;
               <a href="metods.html"><span>Методи за създаване</span></a>&middot;
               <a href="sort.html"><span>Алгоритми за сортиране</span></a>&middot;
		    <a href="map.html"><span>Карта на сайта</span></a></p>
</div>
</body>
</html>