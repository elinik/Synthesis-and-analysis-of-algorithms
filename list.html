<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-5" />
	<meta name="Author" content="Elitsa Nikolova" />
	<meta name="Robots" content="index,follow" />
	<meta name="Description" content="Synthesis and Analysis of Algorithms" />
	<meta name="Keywords" content="Synthesis,Analysis,Algorithms" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<title>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</title>
    <style type="text/css">
<!--
.style1 {
	font-size: 1.2em;
	color: #333333;
}
.style7 {font-size: 1.2em}
.style13 {font-size: 0.7em}
-->
    </style>
</head>
<body>
	<div id="main">
<ul id="menu">
<li><a href="sort.html"><span class="key">Алгоритми за сортиране</span></a></li>
            <li><a href="metods.html"><span class="key">Методи за създаване</span></a></li>
            <li><a href="struct.html"><span class="key">Структури данни</span></a></li>
            <li><a href="struct.html"><span class="key">Алгоритми</span></a></li>
</ul>
		
  <div id="intro_left">
			<p>Алгоритмите в сайта са описани на псевдокод, което ги прави по-лесни за четене и разбиране.</p>
	  </div>
		
		<div id="intro_right">
			<p class="white">УЕБ БАЗИРАНО ПРИЛОЖЕНИЕ ПО</p>
		  <h1>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</h1>
			<p></p>
		</div>

  <ul id="menu_left">
			<li><a href="steak.html"><span>Стек</span></a></li>
		<li><span><a href="tail.html">Опашка</a></span></li>
		<li><a href="list.html"><span>Списък</span></a></li>
        <li><span><a href="tree.html">Дърво</a></span></li>
		<li><span><a href="task02.html">Задачи</a></span></li>
	  </ul>
      
			<div class="special">
			  <h1>Структура от данни линеен списък			  </h1>
			  <p>Линейният списък е  линейна динамична структура, но за разлика от опашката, тук включването и  изключването могат да стават на произволно последователността. Обичайно едно от  полетата за информация за един от списъка играе ролята на ключ за идентификация на  елемента и оби елементите на списъка са подредени в нарастващ ред на ключовете  с наредба определя мястото на включване на нов елемент, а след изключ елемент  от списъка, останалите елементи трябва отново да са подре; ключовете си. Това  би могло да се направи и при компактно предста елементите на списъка, но  операциите за включване и изключване ще v преместване на елементи  в паметта. Затова един линеен списък оби свързваме с верижно представяне,  заради удобствата за операциите вклю изключване. </p>
			  <div>
                <table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="48">
                  <tr>
                    <td valign="top" align="left" height="48"><br />
                        <img width="381" height="64" src="images/list_image002.jpg" alt="image40" /> </td>
                  </tr>
                </table>
		      </div>
			  <p><u>Верижно представяне на списък чрез структурата масив</u><br />
			    Да приемем за простота, че елемент на списъка  има проста структура <br />
              </p>
			    
			  </p>
              <br clear="all" />
              <div> <br clear="all" />
                  <p><img width="387" height="67" src="images/list_image004.jpg" alt="image41" /><br clear="all" />
                    За  резервиране на адресно пространство за елементите на списъка може да използваме  масив с тип на елементите, съвпадащ с типа info. Във  всеки случай за представяне на указателя към следващ елемент във веригата е  необходимо добавянето на паралелен масив с тип integer , тъй  като указателят ще има стойност - индекс на следващия елемент. Така списъкът <br />
                    може  да бъде представен например така: <br />
                    <img width="207" height="200" src="list_image005.gif" align="left" hspace="7" alt="Текстово поле: info" />1 <br />
                L- 2 </p>
                <p>&nbsp;</p>
                <p>&nbsp;</p>
                <p>&nbsp;</p>
                <p><img width="138" height="41" src="list_image007.jpg" alt="image42" /><br clear="all" />
                  Към  това трябва да свържем със списъка и една целочислена променлива, например list, която  се нарича указател на списъка и чиято стойност сочи  към първия елемент от списъка. Празен списък има стойност на указателя си  такава, че да не сочи към валиден елемент от масива, например list = 0.  Това отговаря на следната схема <br />
                  След решението за конкретното физическо представяне на списъка  следва да се реализират процедурите за извършване на операциите над списъка:  инициализация на празен списък, обход на текущото състояние на списъка и  операциите включване и изключване на елемент от списъка. <br />
                  Операцията <em>инициализация </em>трябва да създаде празен  списък. Това става със: <em>init(list); </em><br />
                  <em>list:= </em><em>0</em><em>; </em><br />
                  <em>Обхождането </em>на списъка  може да стане само от първия му елемент и последователно се обхождат всички  елементи до достигане на края на списъка: <br />
                  <em>prntlist(list); </em><br />
                  <em>1 </em>:= <em>list; </em><br />
                  <em><u>докато</u></em><em><u> </u></em><em>1 </em>&#8800;О <em><u>прави</u></em><br />
                  <em>печат  (in</em><em>f</em><em>o  [l]); </em><br />
                  <em>1:  =next[l</em><em>]</em><em>; </em><br />
                  Следващите две операции променят  текущото състояние на списъка. <br />
                  Операция <em>включване </em>на  елемент с ключ <em>х. </em>Нека списъкът е подреден във възходящ ред по частта <em>in</em><em>f</em><em>o. </em>Стъпките, които трябва да се  извършат са както следва: </p>
                <ol>
                  <li>Намиране на свободно място с  адрес <em>р </em>в адресното пространство и запис в информационната част на това  пространство. </li>
                  <li>Намиране  на място на елемента в списъка според ключа му между елементите с адреси <em>lр </em>и <em>1 . </em></li>
                  <li>Привързване на елемента в  списъка. </li>
                </ol>
                <p>Програмното решение на отделните  стъпки е: </p>
                <ol>
                  <li>Нека засега приемем, че  разполагаме с процедура <em>getnode(p), </em>която връща свободен адрес <em>р, </em>ако има такъв, и нула, ако е  запълнено адресното пространство. В последния случай операцията по включването  ще бъде неуспешна. </li>
                </ol>
                <p><em>getode(p); <u>ако</u> р&#8800;</em><em>0</em><em><u>то</u></em><em> in</em><em>f</em><em>o[p</em><em>]</em><em>:=x; </em></p>
                <ol>
                  <li>Обход  на списъка за намиране на място на новия елемент. </li>
                </ol>
                <p><em>lp </em>:= <em>list;l:= list; </em><br />
                      <em><u>докато</u></em><em>l</em><em>&#8800; </em>О <em>and х </em>&gt; <em>info[l</em><em>] </em><em><u>прави</u></em><br />
                      <em>lр:= </em><em>l</em><em>; </em><em>l</em><em>:= next[l]; </em></p>
                <ol>
                  <li>Привързване в списъка. Тук има  две възможни ситуации: ако ключът на включвания елемент е по-малък от ключа още  на първия елемент във списъка, в горния  итеративен цикъл няма да се влезе нито веднъж. Тогава двата  &quot;указателя&quot; <em>1 </em>и <em>lр </em>имат една и съща стойност, равна на <em>list. </em>В този случай елементът трябва да се включи като пръв в списъка и това ще доведе до изменение на указателя на  списъка <em>list. </em>Втората ситуация е, когато елементът се включва някъде  вътре в списъка (включително и като последен). В този случай той има реален  предходник с адрес в &quot;указателя&quot; <em>lр. </em>Това е отразено в  следната стъпка от алгоритъма: </li>
                </ol>
                <p><em><u>ако</u></em><em> l=lp <u>то</u> next[p] </em>:= <em>list; list:= р <u>иначе</u></em><br />
                      <em>next[p] </em>:= <em>next[lp]; </em><br />
                      <em>next[lp] </em>:= <em>р; </em><br />
                  Така  цялата процедура включване става: <em>inlist(x,list,jl) </em><br />
                  <em>fl </em>:= <em>false; getnode(p); <u>ако</u> pi'O <u>то</u> jl:=trие; iпjo[p</em><em>]</em><em>:=x; </em><br />
                  <em>l:=list; lp:=list; </em><br />
                  <em><u>докато</u></em><em>l&#8800;</em>О <em>and х </em>&gt; <em>info</em><em>[</em><em>l</em><em>]</em><em><u>прави</u></em><br />
                  <em>lр := </em><em>l</em><em>;</em><em> l</em><em>:=  next[</em><em>l</em><em>]; </em><br />
                  <em><u>ако</u></em><em> l</em><em>=lp <u>то</u></em><br />
                  <em>next[p]:= list; </em><br />
                  <em>list:= р </em><br />
                  <em><u>иначе</u></em><br />
                  <em>next[p] </em>:= <em>next[lp]; </em><br />
                  <em>next[lp]:= р; </em><br />
                  Операция <em>изключване </em>на  елемент със зададен ключ <em>х. </em>За  реализирането на тази операция следва да се изпълнят следните стъпки: </p>
                <ol>
                  <li>Откриване на елемента подлежащ на  изключване под адрес <em>1 </em>с  предходник в адрес <em>lр. </em>Тази стъпка изисква обхождане на списъка до  откриване на търсения елемент. Ако до края на списъка елементът не се открие,  операцията изключване ще бъде неуспешна; </li>
                  <li>Отвързване на елемента от списъка  (байпас); </li>
                  <li>Освобождаване на заеманото от  елемента място в адресното пространство. </li>
                </ol>
                <p>Програмното решение на отделните  стъпки: </p>
                <ol>
                  <li> Обход  на списъка до намиране на търсения елемент: </li>
                </ol>
                <p><em>1:= list; lp </em>:= <em>list; </em><br />
                      <em><u>докато</u></em><em>1 </em><em>l&#8800;</em><em>О</em> <em>and  info[</em><em>l</em><em>]</em><em>l&#8800;</em><em>х <u>прави</u> lр </em>:= <em>1; 1 </em>:= <em>next[l]; </em><br />
                  Ако от итеративния цикъл се  излезе с <em>1 </em>= 0, това означава, че списъкът  изцяло е обходен и елементът не е открит. </p>
                <ol>
                  <li> Отвързване  на елемента от списъка. Тук отново има две ситуации: изключва се първи елемент,  тогава той няма реален предходник и се променя указателят на списъка; или се  изключва вътрешен или последен елемент, адресът на предходника му е в  &quot;указателя&quot; <em>lр . </em></li>
                </ol>
                <p><em><u>ако</u></em><em> lр=l <u>то</u> </em><br />
                      <em>list:= next[l]; </em><br />
                      <em><u>иначе</u></em><br />
                      <em>next[lp] </em>:= <em>next[l]; </em></p>
                <ol>
                  <li>Освобождаване на мястото на  изключвания елемент: нека засега приемем, че това се решава от процедурата <em>freenode(l). </em></li>
                </ol>
                <p>Цялата процедура изключване  става: <br />
                      <em>outlist(x,list, jl) </em><br />
                      <em>l</em><em>:= list; </em><em>l</em><em>р &gt; list; jl:= false; </em><br />
                      <em><u>докато</u></em><em>l</em>&#8800;О <em>and info[</em><em>]&#8800;</em> <em>х <u>прави</u> </em><br />
                      <em>l</em><em>р </em>:= <em>l</em><em>; l</em>:= <em>next[l]; </em><br />
                      <em><u>ако</u></em><em> 1 </em>&#8800;0 <em><u>то</u></em><br />
                      <em>f</em><em>l:= </em><em>true</em><em>; </em><br />
                      <em><u>ако</u></em><em>l</em><em>р=l <u>то</u></em><em><u> </u></em><br />
                      <em> list </em>:= <em>next[l]; </em><br />
                      <em><u>иначе</u></em><br />
                      <em>next[lp] </em>:= <em>next[l]; freenode(l); </em><br />
                  За да  могат да работят процедурите по включване и изключване на елементи, трябва да се решат алгоритмите на процедурите <em>getnode </em>и <em>Jreenode. </em>За тази цел трябва да се поддържа информация за  свободното адресно пространство. Това може да стане чрез поддържане на един  списък на свободните места с указател,  например <em>heap. </em><br />
                  Като имаме предвид, че елементите  на списъка на свободните места нямат информационна част, а ако едно място в  масива <em>info </em>е свободно и съответното му  място в масива <em>пехл </em>е свободно, то списъкът <em>heap </em>може да  се поддържа от същия масив <em>next. </em><br />
                  Включването на нов елемент в основния  списък ше означава изключване на елемент от списъка на свободното пространство <em>heap </em>и обратно - изключването на елемент от основния списък ще означава  включване на мястото му в списъка <em>heap</em><em>.</em></p>
              </div>
              <em><br clear="all" />
              </em>
              <div>
                <p>Инициализацията  на празен основен списък ще означава създаване на пълен списък на свободното  престранство. С това уточнение, процедурата <em>init </em>ще се промени така: <br />
                    <em>init(list, heap); </em><br />
                    <em>list:= </em><em>0</em><em>;heap:= 1; </em><br />
                    <em><u>за</u></em> <em>i</em>:= 1 <em>до тах <u>прави</u> </em><br />
                    <em>next[i]:=  i</em>+ 1; <br />
                    <em>next[ тах </em>] := О; <br />
                  Няма значение кой елемент ще се  изключва от списъка на свободното пространство при процедурата getnode и на кое  място ще се включва елемент в списъка heap при процедурата freenode. Тогава  двете операции изключване и включване в heap могат да се решат по принципа на  стек: включва се и се изключва връх на стек, поддържан верижно. </p>
                <p><u>Реализация  на линеен списък чрез използване на динамична памет </u><u> </u><br />
                  Под  динамична памет разбираме адресно пространство, което е вън ( паметта, заета от  програмата, и което може в процеса на работата й да бъ; използвано. За да бъде  възможно това, трябва езикът за програмиране (в случая  Паскал) да има следните възможности: </p>
                <ol>
                  <li>Възможност  за използване на променливи-указатели, т.е.  таки променливи, чиито стойности са адреси; </li>
                  <li>Възможност  чрез тези променливи да се вземат адреси от свободно: адресно пространство. </li>
                </ol>
                <p>Указатели  - това са променливи от прост тип като цяло, реално и т.н. За т) обаче няма  предефинирана дума. Това е така, защото указателят може да е таю към произволен  тип величина. Затова указателят се описва в раздела type 1 програмата  като указател към определен тип обект: type ptr =  &lt;обект&gt;; <br />
                  Всяка променлива от тип <em>ptr </em>ще бъде указател към  величина от тип &lt;обект&gt; <em>var ptl, pt2 </em>: <em>ptr; </em><br />
                  Съдържанието  на променливите <em>ptl </em>и <em>pt2 </em>са адреси, съдържанието на които'  величини от тип &lt;обект&gt;. Например, нека <br />
                  <em>type ptr </em>= <em>rеаl; </em><br />
                  <em>var ptl,pt2,ptr; </em><br />
                  За да можем да представим  последователност от данни като верижно представена структура с използване на  указатели, в състава на всеки елемент от структурата, определен като  &lt;обект&gt;, трябва да има поле за указател. За това е необходим <em>комбиниран  тип </em>- запис. Така дефиницията на елемент от  линеен списък изисква следните две определения на типове: <br />
                  <em>type ptr </em>= <em>obj</em><em>есt; </em><br />
                  <em>object </em>= <em>record info: </em>&lt; <em>data </em>&gt;; <em>пех</em><em>t</em><em> :ptr; </em><br />
                  <em>end; </em><br />
                  Тук езикът Паскал решава въпроса за &quot;яйцето и кокошката&quot;, като  позволява описанието на указател към обект <em>преди </em>описанието на самия обект, но не и <em>след </em>него. <br />
                  Нека разгледаме линеен списък с посочената по-горе структура на елемент. <br />
                  С всеки списък е свързана една променлива тип указател,  която се нарича указател на списъка. Съдържанието на тази променлива е адресът  на първия елемент от списъка, или е <em>nil, </em>ако списъкът е празен. <br />
                  <em>var list,</em><em>pl</em>: <em>ptr; </em><br />
                  За да създадем празен списък,  достатъчно е да изпълним <em>list:= nil; </em><br />
                  За да включим елемент в списъка, трябва: </p>
                <ol>
                  <li>Да вземем памет от свободното  пространство за един елемент от тип <em>object. </em>Това става с процедурата <em>new: </em></li>
                </ol>
                <p><em>new(pt); </em><br />
                  Дотук имаме: </p>
             
                <p><img src="images/list_image010.jpg" alt="img10" width="120" height="49" /><img src="images/list_image011.jpg" alt="img11" width="259" height="41" />&nbsp;<br clear="all" />
                </p>
            
               
           
                <p>Всяко  поле от обекта, сочен от <em>р</em><em>t </em>се указва с <br />
                  <em>р</em><em>t</em><em>.</em><em>^</em><em>info, р</em><em>t</em> ^<em>.пех</em><em>t</em><br />
                  тъй като  по определение <em>р</em><em>t^</em> е  запис с отделни полета. </p>
                <ol>
                  <li> Данните за елемента се записват с </li>
                </ol>
                <p><em>р</em><em>^</em><em>.info </em>:= <em>х; </em></p>
                <ol>
                  <li>Включването  на елемента (като пръв в списъка) става със: </li>
                </ol>
                <p><img src="images/list_image013.jpg" alt="img13" width="196" height="77" /><em>pt^</em> <em>.пех</em><em>t</em>:= <em>list; </em><br />
                    <em>list:= pt;</em> </p>
                <p>&nbsp;</p>
                <p>Ако  искаме да изключим този елемент и да освободим заеманата памет: <br />
                  <em>list </em>:= <em>р</em><em>t^</em> <em>.next; </em><br />
                  <em>dispose(pt); </em><br />
                  Една  операция върху текущото състояние на един линеен списък е операцията <em>обход  на списъка. </em>Това означава, започвайки от указателя на списъка  последователно преминаване през елементите му с оглед върху всеки елемент да се  извърши някаква операция. Нека това в конкретния случай е отпечатване на  съдържанието на информационната част на елемент. Процедурата за обход ще  изглежда така: <br />
                  <em>scan(list);  pt:= list; </em><br />
                  <em><u>докато</u></em><em> р</em><em>t:&#8800;nul</em><em><u>прави</u></em><br />
                  <em>nечат( pt </em>^<em>.info </em>); <br />
                  <em>рt</em>:= <em>pt</em><em>^</em><em>.next; </em><br />
                  Операциите включване на елемент и  изключване се реализират аналогично на същите операции, реализирани върху  представяне на списък чрез масив. Разликата сега е, че вместо индекс на място в  адресното пространство на масива, използваме променлива-указател, сочеща адрес  от динамичната памет. <br />
                 <p> Операция  включване на елемент с ключ <em>х </em>в линеен списък с указател <em>list. </em> </p><br />
                  <em>inlist(list,x,fl)  ; </em><br />
                  <em>f</em><em>l.=false; </em><br />
                  <em>new(pt); </em><br />
                  <em><u>ако</u></em><em>р</em><em>t&#8800;</em> <em>nil <u>то</u> </em><br />
                  <em>f</em><em>l:=true;</em><br />
                  <em>рt</em><em>^.</em><em>infо:=х; </em><br />
                  <em>l</em><em>: =list; lр: =list; </em><br />
                  <em><u>докат о</u></em><em>l</em>&#8800;<em>nil and</em><em>l^</em> <em>.info </em>&lt; <em>х <u>прави</u></em><br />
                  <em>lp:=l; </em><em>l</em><em>:=</em><em>l^.</em><em>nехt; </em><br />
                  <em><u>ако</u></em><em> l=lp <u>то</u></em><br />
                  <em>рt</em><em>^.</em><em>nехt:=list; list:=pt; </em><br />
                  <em><u>иначе</u></em><br />
                  <em>рt</em><em>^.</em><em>nехt:=lр</em><em>^.</em><em>nехt; Iр</em><em>^</em><em>.nехt:=рt; </em><br />
                   <p>Операция изключване на елемент с  ключ <em>х </em>от списък с указател <em>list. </em> </p><br />
                  <em>оиt l</em><em>i</em><em>st (lis</em><em>t,</em><em>x,</em><em>f</em><em>l); </em><br />
                  <em>f </em><em>l:=false; </em><br />
                  <em>l </em><em>: =list; lр: =list; </em><br />
                  <em><u>докато</u></em><em> 1</em>&#8800;<em>nil and 1</em><em>^</em> <em>.info </em>&#8800;<em>х <u>прави</u></em><em><u> </u></em><br />
                  <em> lp:=l; </em><em>l</em><em>:=</em><em>l^</em><em>.nехt; </em><br />
                  <em><u>ако </u></em><em> 1</em>&#8800;<em>nil <u>то</u></em><br />
                  <em>f</em><em>l:=true; </em><br />
                  <em><u>ако </u></em><em>l</em><em>=lp <u>то</u> list: =</em><em>l^.</em><em>next; </em><br />
                  <em><u>иначе </u></em><br />
                  <em>l</em><em>р</em><em>^</em><em>.nехt: =</em><em>l^</em><em>.пех</em><em>t</em><em>; </em><br />
                  <em>dispose(l); </em></p>
                <p>&nbsp;</p>
              </div>
			  <h1 align="center">&nbsp;</h1>
	  </div>
	   <a style="display:scroll;position:fixed;bottom:10px;right:10px;" href="#" title="В началото"><img width="30" height="30" src="images/button.png"/></a>  
</div>
	
<div id="footer">
			<p>&copy; Copyright Synthesis and Analysis of Algorithms &middot; 2017 &middot; Design: Elitsa Nikolova&middot; 
			 
			  <a href="index.html"><span>Алгоритми</span></a>&middot;
              <a href="struct.html"><span>Структури данни</span></a>&middot;
               <a href="metods.html"><span>Методи за създаване</span></a>&middot;
               <a href="sort.html"><span>Алгоритми за сортиране</span></a>&middot;
		    <a href="map.html"><span>Карта на сайта</span></a></p>
</div>
</body>
</html>