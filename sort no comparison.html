<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-5" />
	<meta name="Author" content="Elitsa Nikolova" />
	<meta name="Robots" content="index,follow" />
	<meta name="Description" content="Synthesis and Analysis of Algorithms" />
	<meta name="Keywords" content="Synthesis,Analysis,Algorithms" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<title>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</title>
    <style type="text/css">
<!--
.style1 {
	font-size: 1.2em;
	color: #333333;
}
.style7 {font-size: 1.2em}
.style13 {font-size: 0.7em}
-->
    </style>
</head>
<body>
	<div id="main">
<ul id="menu">
<li><a href="sort.html"><span class="key">Алгоритми за сортиране</span></a></li>
            <li><a href="metods.html"><span class="key">Методи за създаване</span></a></li>
            <li><a href="struct.html"><span class="key">Структури данни</span></a></li>
            <li><a href="struct.html"><span class="key">Алгоритми</span></a></li>
</ul>
		
  <div id="intro_left">
			<p>Алгоритмите в сайта са описани на псевдокод, което ги прави по-лесни за четене и разбиране.</p>
	  </div>
		
		<div id="intro_right">
			<p class="white">УЕБ БАЗИРАНО ПРИЛОЖЕНИЕ ПО</p>
		  <h1>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</h1>
			<p></p>
		</div>

  <ul id="menu_left">
			<li><a href="sort quick.html"><span>Бързо сортиране</span></a></li>
			<li><a href="sort merge.html"><span>Сортиране чрез сливане</span></a></li>
			<li><a href="sort  pyramid.html"><span>Сортиране чрез дърво. Пирамидално сортиране</span></a></li>
            <li><a href="sort no comparison.html"><span>Сортировка без сравнения</span></a></li>
		<li><a href="task04.html"><span>Задачи</span></a></li>
	  </ul>
			<div class="special">
			  <h1>Сортировка без  сравнения </h1>
			  <p>Разгледаните  дотук методи за сортиране, както базовите, така и ускорените, в основата си не  предполагат нищо относно стойностите на елементите, подлежащи на сортиране,  освен наличието на наредба в множеството от тези стойности. Това означава, че  има такава функция, която показва, че дадена стойност е &quot;по-малка&quot; от  друга стойност. Основна операция при тези алгоритми е операцията сравнение,  основаваща се на такава функция. Оценявайки именно операциите сравнение, за  базовите алгоритми получихме оценка <em>О(n2), </em>а за ускорените -  О( <em>п </em>log <em>n). </em>Понякога обаче може да се подобри и тази оценка, ако  разполагаме с допълнителна информация за сортируемите стойности. <br />
			    Една крайна ситуация бихме имали, ако предположим  следното: трябва да сортираме масив А от <em>п </em>елемента, чиито стойности не  се повтарят и са цели числа в диапазона  от 1 до <em>п . </em>В този случай, използвайки <em>прекия достъп </em>до елемент  от масив, може да сортираме елементите <br />
			    на А в В със следния прост алгоритъм: <br />
  <em><u>за</u></em><em> i:=1 <u>до</u></em><em> n <u>прави</u></em><em><u> </u></em><br />
  <em> B[A[i]]:=a[i];</em><br />
			    Да отбележим, че: </p>
			  <ol>
			    <li>тук въобще нямаме сравнения, а използваме факта,  че елемент на масив е достъпен директно, без търсене; </li>
			    <li>цикълът изисква изпълнение на операции от  порядъка <em>О(n); </em></li>
			    <li>алгоритъмът ще работи вярно само при направените  предположения относно стойностите на елементите <em>A[i].</em> </li>
		      </ol>
			  <p>Разбира се, рядко може да се очаква, че подлежащият на  сортиране масив удовлетворява направените много силни ограничения. Едно от тях  е, че стойностите на елементите не се повтарят и всеки елемент на В ще  съхранява само един елемент на А. Нека отслабим това предположение и сега  приемем, че имаме да сортираме <em>п </em>елемента на масива А, чиито стойности,  може и с повторение, са разположени в интервал от 1 до <em>т. </em>Тогава <em>k </em>-тата позиция в редицата В вече  може да съхранява повече от един елемент на А; по-точно, ще съхранява всички  онези елементи на А, които имат стойност <em>k. </em>Тогава всяка <em>k </em>-та  позиция на В може да се разглежда като  указател към списък от елементи на А със стойност <em>k </em>. Алгоритъм за  сортиране може да се реализира в следните две стъпки: </p>
			  <ol>
			    <li>едно обхождане на масива А и включване на  поредния му елемент в подходящия според стойността <em>k </em>= <em>A[i] </em>списък с указател в <em>В[ k];</em> </li>
			    <li>последователно обхождане на  списъците с указатели в В и конкатенацията им в една изходна редица <em>C</em>. </li>
		      </ol>
			  <p>За да опишем алгоритъма, нека приемем следното представяне на  данните: да приемем, че данните в масива А са от изброим тип, например цели  числа в диапазона от 1 до <em>т; </em>един елемент от списъка с начало в елемент  от В има структура <br />
                  <em> р</em><em>t </em>= <em>^еlеmеnt; </em><br />
                  <em>      element </em>= <em>record </em><br />
                  <em>      пит: integer; </em><br />
                  <em>     next :pt; </em><br />
                  <em>end; </em><br />
			    а В  е масив <em>[1 .. т] </em>от указатели към <em>element </em>. Така в списъците с  указатели в В се съхраняват не самите елементи на А, а техните номера, с оглед,  ако структурата на елемент от А е сложна, да се местят по-малко данни в  паметта. Нека <em>С</em> е работен масив със  структурата на А. Да приемем още, че процедурата <em>insert(i,list) </em>включва  номера на <em>i</em> -тия елемент на А в  списък с указател <em>list. </em><br />
  <em>алгоритъм binsort </em><br />
  <em><u>за</u> j:= </em>1 <em><u>до</u> т <u>прави</u> </em><br />
  <em>В[</em><em>j]:=  nil; </em><br />
  <em>{разнасяне на елементите на А  в списъците в В</em><em>}</em><br />
  <em> <u>за</u></em> i:= 1 <em><u>до</u> n <u>прави</u></em><br />
  <em>insert(i, В[ A[i]]); </em><br />
  <em>{конкатенация на списъците в масив </em><em>С</em><em>}</em><br />
  <em>l:= 1; </em><br />
  <em><u>за</u> j:= </em>1 <em><u>до</u> т <u>прави</u> р:= В[</em><em>j]; </em><br />
  <em><u>докато</u> р</em>&#8800;<em>nil <u>прави</u></em><br />
  <em>C[l]:= А[р</em><em>^ .nит]; </em><em>l:= </em><em>l </em>+ 1; <em>р:= р</em><em>^.next; </em><br />
			    В резултат от работата  на алгоритъма <em>binsort </em>в масива С са елементите на А в сортиран вид. <br />
			    Анализът на описания алгоритъм показва, че ако се сортират <em>п </em>елемента, които могат да имат <em>т </em>различни  стойности, то порядъкът на необходимото време е <em>О(n+т). </em>Ако приемем, че <em>n>т, </em>каквато е обичайната ситуация, то оценката е <em>О(n). </em>Важно свойство на  алгоритъма <em>binsort </em>е, че той работи правилно, независимо от това, че  много елементи от редицата за сортиране имат една и съща стойност (един и същ  ключ). </p>
			  <p><u class="blue">Устойчиво сортиране </u><br />
			    Когато сортираме редица от елементи, някои от които могат да  имат равни ключове, е важен начинът, по който се подреждат елементите с равни  ключове. Казваме, че даден алгоритъм за сортиране е <em>устойчив, </em>ако за  всеки два елемента Аi и Aj с равни ключове, т.е. <br />
			    Аi = Aj, от  които Аi предхожда Aj  във входната редица, т.е.   <em>i</em> &lt;  <em>j</em>,  то  Аi предхожда Aj и в изходната редица след сортирането. <br />
			    За да  се види защо устойчивостта е важна, да разгледаме следния пример. <br />
			    Нека  е зададена редица от двойки цели числа, всяко число от които е в интервала [0.9]<br />
  <em>(k1, l1), (k2,  l2), ., (kn, ln)</em><br />
			    Например,  можем да разглеждаме тези двойки като представящи цифрите на десетични числа от  0 до 99. В този случай  е естествено да дефинираме наредба според <em>лексикографичната </em>конвенция  (речникова), при която <br />
  <em>(k</em><em>i,l</em><em>i) </em>&lt; <em>(kj,lj) </em><br />
			    ако или <br />
			    (1)                   <em>ki </em><em>&lt;</em><em>kj</em><br />
			    или <br />
  <em>(2)                     </em><em>ki =kj, </em>но <em>li &lt;lj' </em><br />
			    Да разгледаме редицата <br />
			    (3)            (3,5), (8,1), (4,2), (3,1), (6,5),  (3,2) . <br />
			    Да  приложим алгоритъма <em>binsort, </em>сега с масив от указатели <em>В[</em><em>0 .. 9], </em>отначало по  първия ключ <em>k</em><em>i. </em>Получаваме  редицата <br />
			    (3,5),  (3,1), (3,2), (4,2), (6,5), (8,1). <br />
			    Така  сме удовлетворили критерий за наредба (1), но не и критерий (2). Ако сега  приложим още веднъж <em>binsort </em>върху последната редица, този път по  ключовете <em>li </em>ще получим редицата <br />
			    (3,1),  (8,1), (3,2), (4,2), (3,5), (6,5) , <br />
			    която  очевидно не е сортирана по искания начин. <br />
			    Ако обаче първо сортираме устойчиво (3) с <em>binsort </em>по  втория ключ <em>li </em>ще получим редицата <br />
			    (8,1), (3,1), (4,2),  (3,2), (3,5), (6,5) . <br />
			    Тук  е важно да отбележим, че елементите (3,1), (3,2), (3,5) с равни първи ключове  са се появили в изходната от <em>binsort </em>редица в ред, определен от вторите  ключове. Важно е повторното приложения на <em>binsort, </em>сега по първите  ключове <em>ki, </em>да е устойчиво, за да запази тази наредба и да  удовлетвори критерий (2). Тази повторна сортировка води към редицата <br />
			    (3,1), (3,2), (3,5),  (4,2), (6,5), (8,1), <br />
			    която вече наистина е  лексикографически сортирана. <br />
			    Този пример показва, че устойчивото приложение на <em>binsort </em>изисква  поддържането на списъците в В по принципа на опашка FIFO, което означава, че  всеки елемент на В представлява запис от два указателя <em>first, last </em>за  пръв и последен елемент на опашката. Съответно процедурата <em>insert </em>за  включване в списък в алгоритъма <em>binsort </em>ще се замени с процедура за  включване в опашка <em>inqueue(i, k, р </em>л <em>.first,  р </em>л <em>.last) </em>при сортиране по <em>k </em>-та компонента. <br />
			    Разгледаният пример за двойки числа може да се обобщи  например за <em>d­</em><em>-</em>цифрени числа, или символни  низове с еднаква дължина <em>d </em>&gt; 2 . Тогава лексикографичната наредба се  дефинира така: <br />
  <em>(g</em><em>1,g2,. .. ,gd) </em>&lt; <em>(</em><em>h1</em><em>,</em><em>h2</em><em>, ... </em><em>,hd)</em><em>,</em><br />
			    ако съществува такъв номер<em> j, (1 &#8804; j &#8804; k), </em>че <br />
  <em>g1=h1,.gj-1=hj-1 </em>и<em>gj&lt;hj</em><br />
		      Сортировката на такива <em>d </em>-торки, наречена поразрядна сортировка или <em>radixsort , </em>ще протече по следната схема:  последователно се прилага устойчив  <em>binsort </em>по поредните компоненти на <em>d </em>-торките, започвайки от компонента <em>d; </em>върху изходната редица от тази сортировка се прилага <em>binsort </em>по  компонента <em>d-1 </em>и Т.н. до приложение на <em>binsort </em>по първата  компонента. </p>
			  <p><br />
                <em>алгоритъм radixsort </em><br />
                <em>{зададена е редица А  от п елемента (al,a2, ... ,ad)} </em><br />
                <em><u>за</u> k:= d <u>със  стъпка</u></em> -1 <em><u>до</u></em> 1 <em><u>прави</u></em><br />
                <em><u>за</u></em> <em>i</em>:=1 <em><u>до</u> т <u>прави</u></em><br />
                <em>B[i].first:=  n</em><em>il; B[i].last:=  n</em><em>il; </em><br />
                <em><u>за</u></em><em> i</em>:= 1 <em><u>до</u> п <u>прави</u></em><br />
                <em>inqиеие(i,  k,В[А[i]].first,В[А[i]].lаst); </em><br />
                <em>l:= 1; </em><br />
                <em><u>за</u></em> <em>i</em>:= 1 <em><u>до</u> т <u>прави</u></em><em><u> </u></em><br />
                <em> р:= B[i]</em><em>.first; </em><br />
                <em><u>докато</u> р </em>&#8800;<em>nil <u>прави</u></em><br />
                <em>C[l]:=  А[р</em><em>^</em> <em>.пит]; </em><em>l </em>:= <em>l</em>+ 1; <em>p </em>:= <em>p</em><em>^</em> <em>.next; </em><br />
                <em><u>за</u></em> <em>i</em>:= 1 <em><u>до</u> п <u>прави</u> A[i]:= C[i]; </em></p>
			  <h1>&nbsp;</h1>
	  </div>
	   <a style="display:scroll;position:fixed;bottom:10px;right:10px;" href="#" title="В началото"><img width="30" height="30" src="images/button.png"/></a>  
</div>
	
<div id="footer">
			<p>&copy; Copyright Synthesis and Analysis of Algorithms &middot; 2017 &middot; Design: Elitsa Nikolova&middot; 
			 
			  <a href="index.html"><span>Алгоритми</span></a>&middot;
              <a href="struct.html"><span>Структури данни</span></a>&middot;
               <a href="metods.html"><span>Методи за създаване</span></a>&middot;
               <a href="sort.html"><span>Алгоритми за сортиране</span></a>&middot;
		    <a href="map.html"><span>Карта на сайта</span></a></p>
</div>
</html>