<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-5" />
	<meta name="Author" content="Elitsa Nikolova" />
	<meta name="Robots" content="index,follow" />
	<meta name="Description" content="Synthesis and Analysis of Algorithms" />
	<meta name="Keywords" content="Synthesis,Analysis,Algorithms" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<title>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</title>
    <style type="text/css">
<!--
.style1 {
	font-size: 1.2em;
	color: #333333;
}
.style7 {font-size: 1.2em}
.style13 {font-size: 0.7em}
-->
    </style>
</head>
<body>
	<div id="main">
<ul id="menu">
<li><a href="sort.html"><span class="key">Алгоритми за сортиране</span></a></li>
            <li><a href="metods.html"><span class="key">Методи за създаване</span></a></li>
            <li><a href="struct.html"><span class="key">Структури данни</span></a></li>
            <li><a href="index.html"><span class="key">Алгоритми</a></li>
</ul>
		
  <div id="intro_left">
			<p>Алгоритмите в сайта са описани на псевдокод, което ги прави по-лесни за четене и разбиране.</p>
	  </div>
		
		<div id="intro_right">
			<p class="white">УЕБ БАЗИРАНО ПРИЛОЖЕНИЕ ПО</p>
		  <h1>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</h1>
			<p></p>
		</div>

  <ul id="menu_left">
			<li><a href="steak.html"><span>Стек</span></a></li>
		<li><span><a href="tail.html">Опашка</a></span></li>
		<li><a href="list.html"><span>Списък</span></a></li>
        <li><span><a href="tree.html">Дърво</a></span></li>
		<li><span><a href="task02.html">Задачи</a></span></li>
	  </ul>

			<div class="special">
			  <h1>Структура от данни стек 
			  </h1>
			  <p>Стекът е линейна,  динамична структура от данни. Това, което отличава стека от другите такива  структури (опашка, линеен списък), е начинът, по който се извършват операциите достъп и актуализация. Достъпен е единствено  последният включен елемент и той е подлежащият на изключване. Затова за стека се казва още, че е памет от типа "последен влязъл - пръв излязъл", или  LIFO от Last In First Out.<br />
			    Нагледно  стекът може да представим  с купчина  книги: нова книга постъпва в купчината  на върха; достъпна за преглеждане е само книгата  на   върха; първо може да се отстрани само книгата на върха. <br />
			    Като програмна структура стекът е особено подходящ при  съхранение на информация при прекъсвания за извикване на подпрограми. Например при  изпълнение на програмата А се среща  извикване  на  програма   В.  Преди  да предаде управлението на програмата В, следва да се съхрани  информация обектите на програмата А и  за точката на предаване на управлението след завършване на работата  на програмата В. По време на изпълнение  на програмата се среща извикване на програма С. Аналогични  действия за съхранение на информация за състоянието на обектите на В  трябва да се извършат, преди да предаде управлението на програма  С.   След  завършване  на изпълнението програма  С, съхранената информация за прекъснатите изпълнения се възстановява в ред обратен на нейното съхранение. Поради  тази причина,  подходящата структура от данни за  съхранение  на  информация   за  прекъснати  изпълнения стек.<br />
  <img src="images/steak_image002.gif" alt="26" width="317" height="136" /> <br />
			    Реализацията на стек  изисква  физическо представяне на елементите на стека със средствата на езика за програмиране и  реализация на процедури за извършване на дефинираните за стека  операции: инициализация, достъп, включване  и изключване на елемент.<br />
			    Физическото  представяне на стека може да се реализира в Паскал и компактно, и верижно. Ще започнем с  компактно представяне, като за целта ще използваме статичната цтруктура масив за  резервиране на адресно пространство за елементите на  стека. Тъй като стекът е динамична структура,  за да използваме статичния  масив, трябва да предвидим максималната текуща дължина на стека за цялото  време на обработка. Елементите на стека са от един и същ тип, което определя типа на масива.  Нека<br />
  <em>масив  stack[1.. max] от &lt;mun&gt;</em> <br />
			    е резервираното  адресно пространство за стека. Ако стекът има елементи от съставен тип, то масивът   <em>stack</em> ще бъде от записи.  Нека засега да приемем, че един елемент от стека  има проста структура. Тъй като единствено достъпен елемент от стека е  последният включен елемент, със стека се асоциира и променлива (в случая  целочислена), наречена указател  на стека, която сочи елемента връх на стека. </p>
			  <div>
                <table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="79">
                  <tr>
                    <td valign="top" align="left" height="79"><p align="center"><img width="193" height="128" src="steak_image004.jpg" alt="46" /> </p></td>
                  </tr>
                </table>
		      </div>
			  <p class="blue"><u>Процедури за поддържане на стек</u></p>
			  <p>
			    Обичайно  обработката, която изисква използване на стек, започва с празна структура стек,  и завършва когато стекът отново се е опразнил. Ситуацията празен стек се  разпознава по това, че указателят на стека не сочи никакъв елемент от стека,  например нулев указател. Операцията инициализация на стек създава празен стек,  като нулира указателя му: <br />
			    init(stack,stptr) <br />
			    stptr := 0; <br />
			    Операцията  достъп до елемент на стека позволява достъп на елемента, който е на върха на  стека. Тази операция може да завърши неуспешно, ако се прави опит за достъп до  елемент на празен стек: <br />
			    top(stack, stptr, item, fl); <br />
			    fl:= false; <br />
                <u>ако</u> stptr &gt; 0 <u>mo</u> <br />
			    item := stack[stptr];<br />
			    fl := true; <br />
			    Следващите  операции променят състоянието на стека. Операцията включване добавя нов елемент  към стека, като го прави нов връх на стека. Операцията може да е неуспешна, ако  с включването се надхвърля размерът на адресното пространство за стека. <br />
			    push(stack, stptr, item, fl); <br />
			    fl := false; <br />
			    ако stptr &lt;  max mo <br />
			    fl := true; <br />
			    stptr := stptr +1; <br />
			    stack[stptr] := item; <br />
			    Операцията  изключване премахва елемента, който е на върха на стека. Тя може да бъде  неуспешна, ако се прави опит за изключване на елемент от празен стек.<br />
			    pop(stack,stptr, item, fl); <br />
			    fl := false; <br />
			    ако stptr &gt; 0 mo <br />
			    fl := true', <br />
			    item:= stack[stptr]; <br />
			    stptr := stptr-1; <br />
			    След  реализацията на представянето и поддържането на стек можем да че сме разширили  езика с обработка на структурата стек. <br />
                </p>
			  <p><span class="blue"><u>Механизъм за преобразуване на рекурсивен алгоритъм в </u> <u>явно използване на стек</u></span> </p>
			  <p><br />
			    Нека  си припомним рекурсивния алгоритъм за Ханойската кула представим как се  изпълнява той, когато към него има обръщение с n&gt;1.  При  такава стойност на параметъра управлението се предава на  общия случай, поради което трябва да се прекъсне текущото изпълнение и да се  инициира изпълнение от началото на алгоритъма, с параметър п  -1. Преди обаче да се направи това, трябва да се запазят  текущите параметри на прекъснатото изпълнение,  за да може след завършването на породеното от него изпълнение,  прекъснатото да продължи. Когато дадено  поредно рекурсивно извиква през тривиалния случай и се реши директно, трябва да  се възстановят параметрите на прекъснатото от него, за да продължи то.  Възстановяването на съхранените параметри на прекъснато изпълнение става в ред  обратен на съхраняването им; следователно структурата от данни за съхранението  им трябва да е стек. <br />
			    Работата  на целия алгоритъм ще приключи, когато при опит да се елемент от стека за  продължение на прекъсната обработка, се окаже, че стекът е празен. Тъй като  "празен стек" е признак за край на обработката, тя пък започне с инициализация  на "празен стек". <br />
			    След  второто рекурсивно извикване няма продължение; поради причина няма нужда от  съхранение на параметрите на прекъснатото изпълнение. <br />
			    Нека  един елемент от стека е запис с 4 цели полета</p>
			  <div align="center">
                <table width="74" height="70" border="1" cellpadding="0" cellspacing="0">
                  <tr>
                    <td valign="top"><br />
                      n </td>
                    <td valign="top"><p>a</p></td>
                    <td valign="top"><p>b</p></td>
                    <td valign="top"><p>c</p></td>
                  </tr>
                </table>
		      </div>
			  <p>stack{1..max] е масив от такива  записи за резервиране на адресно пространство за стека, a stptr е  неговият указател. Тогава нерекурсивният вариант на алгоритъма за  Ханойската кула ще изглежда така: <br />
			    алгоритъм hanoinr(n,a,b,c); <br />
			    init(stack, stptr); <br />
			    start: ако n = 1 mo <br />
			    печат('мести от а, 'върху b); <br />
			    преход към cont;<br />
			    иначе<br />
			    push(stack, stptr, n,a,b,c); <br />
			    n:=n-1; swap(b, c); <br />
			    преход към start; <br />
			    cont: ако stptr &gt; 0 mo <br />
			    pop{stack, stptr, n, a, b, c); <br />
			    печат('мести от а, 'върху b); <br />
			    n:=n-1; <br />
			    swap(c, a); <br />
		      преход към start; </p>
			  <p><br />
                <u class="blue">Интерпретатор на аритметичен израз</u></p>
			  <p><u> </u><br />
			    Типично  софтуерно приложение на стек се използва при обработката - за интерпретация или  компилация - на израз, аритметичен или булев. Ще разгледаме това приложение при  разработката на интерпретатор на аритметичен израз. <br />
			    Предпоставките  са: имаме входен низ от символи - операнди, операции и фитметични скоби - който  представя синтактически правиленен аритметичен израз. Изразът  е преминал лексически анализ и всеки елемент - операнд, операция, скоба -се  представя с един символ (лексема). <br />
			    Алгоритъмът,  който ще разгледаме, може да се прилага в ситуации, в които следва да се  изпълняват различни операции с въведен между тях приоритет, така те по-ниско  приоритетните операции трябва да изчакат изпълнението на по- високо  приоритетните операции. Задържането (потискането) на по-ниско приоритетните  операции, а следователно и на техните операнди, става именно чрез временното им  съхранение в стек. <br />
			    Техниката  на обработка за компилация и интерпретация е в голяма степен еднаква. Разликата  е, че при компилация се подготвят машинни команди, които це се изпълнят по  време на изпълнение на компилираната програма; при интерпретацията изразът се  изчислява по време на обработката. <br />
			    Нека разгледаме един израз, представен със следните елементи: </p>
			  <ol>
			    <li>операнди, условно представени с букви; това са променливи или  константи; </li>
			    <li>операции с въведен приоритет: умножение (*) и деление (/) с  по-висок приоритет от събиране (+) и изваждане (-); равно приоритетните  операции се изпълняват по реда на срещането им отляво надясно; </li>
			    <li>отварящи и затварящи скоби, които променят реда на  изпълнение. </li>
		      </ol>
			  <p>a+b*(c-d / е) + f <br />
			    Преглеждайки  израза символ по символ, имайки предвид старшинството на итерациите и  присъствието на скобите, следва: <br />
			    преди  да се изпълни операцията събиране (+) върху операндите а и  подизраза b*(c-d/e), тя  трябва да се задържи в стек (стек на операциите); в стек на операндите пък  трябва да се задържат операндите й; </p>
			  <ol>
			    <li>преди да се изпълни умножението (*) върху операндите b и  подизраза (c-d/е), то  трябва да се задържи в стек на операциите до изчислението на подизраза. </li>
		      </ol>
			  <p>Така задържането на операциите и съответно техните операнди  до времето, в което операциите могат да се изпълнят, може да се осъществи с  използването на два стека - стек на операциите (st2) и стек  на операндите (st1).  Следните правила определят действията при проследяване на входния низ символ по  символ: </p>
			  <ol>
			    <li>всеки операнд се включва в стека с операнди st1; </li>
			    <li>всяка операция изважда една след друга по-високо или равно  приоритетните операции от st2 и  самата се включва в него; </li>
			    <li>отваряща скоба, на която се приписва най-нисък приоритет,  пада в стека с операции; </li>
			    <li>затваряща скоба изважда всички операции от стека с операции  до среща на своята отваряща скоба; </li>
			    <li>всяко изваждане на операция от стека с операции означава  нейното изпълнение над операндите на върха на стека с операнди, а резултатът от  нея става нов връх на стека с операнди; </li>
			    <li>след изчерпване на входния низ, до изчерпване се изваждат  операциите от стека с операции по горното правило; </li>
			    <li>след изчерпване на стека с операции, в стека с операнди има  само един елемент и той е резултатът от изчислението на аритметичния израз. </li>
		      </ol>
			  <p>За  да опишем алгоритъма за изчисление на израз, нека приемем, че разполагаме със следните  функции и процедури: </p>
			  <ol>
			    <li>функция prior(symb), тук symb е  операция, а функцията получава стойност цяло число съответно:</li>
		        <li> 0 за отваряща скоба, 1 за  събиране и изваждане и 2 за умножение и деление;                                                                                     </li>
			    <li>пол </li>
			  </ol>
			  <ol>
			    <li>процедура init(stack), която  инициализира като празен указания стек; </li>
			    <li>процедура push(symb, stack) включва  указания символ в указания стек; </li>
			    <li>функция pop(stack) получава  стойността на елемента на върха на указания стек, като го изключва от него; </li>
			    <li>функция top(stack) получава  стойността на елемента на върха на указания стек; </li>
			    <li>функция eval(oprnd1,operation,oprnd2), която  изчислява стойността на резултата от прилагане на operation върху oprnd1 и oprnd2. </li>
		      </ol>
			  <p>Предполага  се, че стойностите на операндите са известни и се намират в подходящо  организирана таблица. Тогава алгоритъмът за изчисление на израза ще изглежда  така: <br />
			    алгоритъм  expression(inpstring) <br />
			    init(st1); init(st2); <br />
			    докато inpstring  &#8800; {} прави <br />
			    symb := пореден символ (inpstring); <br />
			    вариант от symb: <br />
			    'операнд': push(symb,str1); <br />
			    'операция':докато st2&#8800; {} and prior (top(st2))&#8805;  prior(symb) прави <br />
			    op2 := pop(st1); opl1:= pop(st1); <br />
			    push  (eval (op1, pop(st2), op2),st1);<br />
			    push(symb,st2); <br />
			    '(' :          push(symb,st2); <br />
			    ')':          докато  top(st2) &#8800;'(' прави<br />
			    op2:= pop(st 1); op1:= pop(st1);<br />
			    push(eval(op1,pop(st2),op2),st1);<br />
			    t := pop(st2); <br />
			    край на вариант;<br />
			    докато st2 &#8800; {} прави<u> </u><br />
			    ор2 := pop(st1); op1:= pop(st1); <br />
			    push (eval (op1, pop(st2), op2),st1); <br />
			    Както  отбелягахме по-горе при предпоставките за работа на алгоритъма, той ще работи  само ако изразът е синтактически правилен. <br />
                </p>
			  <p><span class="blue"><u>Обработка на израз чрез обратен полски запис</u> </span></p>
			  <p><br />
			    Съществуват и други подходи за обработка на изрази. Един от  тях разделя разгледания вече алгоритъм на две части чрез въвеждане на понятието  обратен полски запис. Известни са три начина  на записване на двуместните операции, например аритметичните. </p>
			  <ol>
			    <li>стандартната infix форма,  когато операцията е между двата си операнда, а<img src="images/steak_image006.gif" alt="66" width="16" height="19" />b,  където а и b са  операнди, а <img src="images/steak_image008.gif" alt="86" width="19" height="19" />е коя  да е аритметична операция; </li>
			    <li>префиксна (prefix)  форма <img src="images/steak_image006_0000.gif" alt="606" width="16" height="19" />ab,  когато операцията предхожда двата си операнда; </li>
			    <li>постфиксна (postfix)  форма ab<img src="images/steak_image006_0001.gif" alt="616" width="16" height="19" />,  когато операцията следва двата си операнда. Тази именно форма са нарича обратен  полски запис (ОПЗ). </li>
		      </ol>
			  <p>Самите операнди а и b могат  да са подизрази, записани в съответната форма. ОПЗ  елиминира  скобите, като отчита тяхното действие. Следните примери показват стандартната  форма на няколко израза и съответно техния ОПЗ: <br />
			    a+b                            ab + <br />
			    a+b*c                                    abc*+ <br />
			    (a+b)*c                      ab+c*<br />
			    a-b*(c + d)          abcd +*- </p>
			  <h1 align="center">&nbsp;</h1>
	  </div>
	   <a style="display:scroll;position:fixed;bottom:10px;right:10px;" href="#" title="В началото"><img width="30" height="30" src="images/button.png"/></a>  
</div>
	
<div id="footer">
			<p>&copy; Copyright Synthesis and Analysis of Algorithms &middot; 2017 &middot; Design: Elitsa Nikolova&middot; 
			 
			  <a href="index.html"><span>Алгоритми</span></a>&middot;
              <a href="struct.html"><span>Структури данни</span></a>&middot;
               <a href="metods.html"><span>Методи за създаване</span></a>&middot;
               <a href="sort.html"><span>Алгоритми за сортиране</span></a>&middot;
		    <a href="map.html"><span>Карта на сайта</span></a></p>
</div>
</html>