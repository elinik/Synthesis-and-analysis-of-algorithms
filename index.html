<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-5" />
	<meta name="Author" content="Elitsa Nikolova" />
	<meta name="Robots" content="index,follow" />
	<meta name="Description" content="Synthesis and Analysis of Algorithms" />
	<meta name="Keywords" content="Synthesis,Analysis,Algorithms" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<title>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</title>
    <style type="text/css">
<!--
.style1 {
	font-size: 1.2em;
	color: #333333;
}
.style7 {font-size: 1.2em}
.style13 {font-size: 0.7em}
-->
    </style>
</head>
<body>
	<div id="main">
<ul id="menu">
<li><a href="sort.html"><span class="key">Алгоритми за сортиране</span></a></li>
            <li><a href="metods.html"><span class="key">Методи за създаване</span></a></li>
            <li><a href="struct.html"><span class="key">Структури данни</span></a></li>
            <li><a href="index.html"><span class="key">Алгоритми</a></li>
</ul>
		
  <div id="intro_left">
			<p>Алгоритмите в сайта са описани на псевдокод, което ги прави по-лесни за четене и разбиране.</p>
	  </div>
		
		<div id="intro_right">
			<p class="white">УЕБ БАЗИРАНО ПРИЛОЖЕНИЕ ПО</p>
		  <h1>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</h1>
			<p></p>
		</div>

  <ul id="menu_left">
			<li><a href="index.html"><span>Алгоритми, изисквания, описание</span></a></li>
			<li><a href="analyses.html"><span>Анализ на алгоритми. Изчислителна сложност. Класификация</span></a></li>
		<li><a href="recursion.html"><span>Рекурсия</span></a></li>
		<li><a href="task01.html"><span>Задачи</span></a></li>
	  </ul>

			<div class="special">
			  
			  <h1>Алгоритми, изисквания, описание</h1>
			  <p> <br />
			    <span class="style7">Алгоритъм  е основно понятие в информатиката. Алгоритмите са идеите, които стоят зад всяка  компютърна програма. За да можем да обсъждаме различните аспекти, свързани с  алгоритмите, ще въведем следното работно определение за алгоритъм. <br />
			    Алгоритъм е крайна  последователност от добре дефинирани крайни инструкции, която изисква крайно  време и крайна памет за изпълнението си. <br />
			    Важно  е да се разбере, че алгоритъмът решава обща  задача, а не отделен случай  на задача. Разликата между задача и отделен случай на задача може да се види от  следния пример. Една често срещана алгоритмична задача за сортиране се дефинира  така: <br />
			    Вход:  Зададена е редица от п  числа а1,а2,...,аn. <br />
			    Изход:  Да се намери пермутация а'1,а'2,...,а'n  на тези числа, така че а'1&lt;а'2&lt;...&lt;а'n. <br />
			    Алгоритъмът  за решение на тази задача трябва да може да приеме всяка възможна редица от п  числа и да я трансформира в желаната изходна редица, в която елементите й са  подредени във възходящ ред. Отделен случай на тази задача е да се сортира  редицата {54,32,3,121,5,86,28}. <br />
			    Много  често първоначалната формулировка на задачата е твърде неясна. Преди да  пристъпим към създаването на алгоритъм за решаването й, задачата трябва да е  формализирана. Ако отделни елементи на задачата могат да се изразят в термините  на някакъв формален модел, то много е възможно да се установи, че вече  съществуват методи и алгоритми за решаването им. <br />
			    Например,  да разгледаме неформалната задача, стояща пред някой, който иска да си определи  маршрут, по който да пътува от София до Уелингтон, Нова Зеландия. Съвременният  свят предлага множество самолетни превозвачи, някои с редовни линии, други са  т.нар. нискотарифни превозвачи, някои са с директни полети, други са с  множество престои и прекачвания. Пътникът може да има различни предпочитания,  но много е възможно да иска да подбере най-евтиния маршрут. <br />
			    За построяването на формализиран модел на тази задача може да  използваме математическата структура граф. Графът  се състои от множество точки, наречени възли,  и множество линии, наречени ребра,  съединяващи възлите. За решението на задачата може да скицираме граф, на който  възлите са отделните летища, а ребрата свързват онези възли, между които има  полети на някой от операторите превозвачи. Цените на отделните полети сij  от летище i до  летище j могат  да се зададат  чрез една квадратна матрица С = {с|ij}.  Всяка последователност от възли, свързани с ребра, която започва от възела  София и стига до възела Уелингтон, се нарича път  в графа между София и Уелингтон. Сумата от цените на ребрата от пътя е цената  на този път. Така първоначалната неформална задача на пътника придоби съвсем  формализиран вид и се свежда до математическата задача: да се намери най-евтин  път между два възела в граф. <br />
			    Нещо  повече (както ще се случва често, ако успеем да формализираме решаваната  задача), ще открием, че има разработени методи и алгоритми за решаване на  формализираната задача за намиране на най-евтин път в граф. <br />
			    Този  пример показва, че за да построи правилен, ефективен и реализуем алгоритъм,  разработчикът трябва да има определени знания. Тези знания могат да се  резюмират така: </span></p>
			  <ol class="style7">
                <li>Да познава и разбира няколко фундаментални техники за  построяване на алгоритми, като метод разделяй и владей, динамично програмиране,  пълно претърсване с възврат, евристики, рекурсия, и може би най-важната техника  - тази на моделирането. Това е изкуството да се преобразува неясната в голяма  степен реална задача в добре формализиран неин модел; </li>
                <li>Да познава и използва основните структури от данни; </li>
                <li>Да умее да се възползва от създаденото преди него: вместо да  се захваща с разработката на всяка задача отначало, да знае как да открие какво  е известно за нейното решение. Това показва, че разработчикът трябва да е  запознат с едно множество от алгоритмични задачи, например като тези за  сортиране, търсене, комбинаторни алгоритми, които осигуряват материал за  моделиране на повечето приложения. </li>
              </ol>
              <h3 class="blue">Описание  на алгоритмите </h3>
              <p class="style7"><br />
                Описанието на алгоритъм изисква  средство за изразяване на последователността  от стъпки, които трябва да се изпълнят. Най-общите средства за описание са:  естествен език, псевдокод и формализиран език за програмиране. Естественият  език е най-лек за ползване, но и най-неточен, тъй като не е строго формализиран  и допуска двусмислие. Езиците за програмиране като Pascal  и С са точни, но са по-трудни за писане и разбиране.  Псевдокодът е полезен, защото е по средата. Той има формализирани управляващи  структури, подобно на език за програмиране, но допуска описание на отделни  стъпки със средствата на естествен език. Точно тези свойства на псевдокода  позволяват постъпковото разработване на един алгоритъм, както ще видим малко  по-долу. <br />
                Изисквания  към алгоритмите <br />
                Естествено  е да искаме един алгоритъм да решава правилно  поставената задача. Усилията да се докаже, че един алгоритъм е правилен са  съпоставими с тези да се докаже теорема, така че да се установи, че за всеки  отделен случай на входни  данни алгоритъмът води към желания резултат. Тук няма да се съсредоточаваме във  формални доказателства за правилност на разработваните алгоритми. Все пак да  обърнем внимание, че освен в случаите на много прости задачи, не винаги е  очевидно, че даден алгоритъм е правилен. За да покажем това, да разгледаме  следната задача: <br />
              </p>
              <p class="style7">Задача  на търговския пътник <br />
                Вход: Зададено е множество Р  от п населени пункта. Търговският пътник трябва, тръгвайки от  начален пункт р , да посети всеки пункт по веднъж и да се <br />
                върне  в отправния пункт. <br />
                Изход:  Да се определи най-късият цикъл,  който обхожда всички пунктове. Могат да бъдат предложени различни алгоритми.  Може би най-простата идея е, започвайки от р  , на всяка стъпка да се избира най-близкия съсед. <br />
                Описанието  на псевдокод на тази идея изглежда така: <br />
                Алгоритъм TSP1(P) <br />
                Избери начален пункт р0<img src="images/index_image002.gif" alt="image2" width="17" height="19" />Р; <br />
                i := 0; <br />
                докато има непосетени пунктове прави<br />
                i:=i+1; <br />
                избери рi= най-близкия  съсед на pi-1;<br />
                посети pi; <br />
                върни се от рi-1 в р0. <br />
                Този  алгоритъм е прост за разбиране и реализация. Но дали е правилен? Наистина,  горният алгоритъм ще даде верен резултат, ако точките от множеството Р  са разположени като на фиг. 1. <br />
                <img width="127" height="113" src="images/index_image004.jpg" align="left" hspace="150" alt="image4" /><br />
              </p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <p class="style7">Фиг. 1. Най-къс цикъл  на обхождане на множеството Р. </p>
              <p class="style7">Но  докато доказателството за правилност изисква да се покаже, че алгоритъмът дава  желания резултат при всеки възможен вход, то да се докаже, че един алгоритъм (и  теорема) не е правилен, достатъчно е да се намери един контрапример. Същият  алгоритъм за множеството Р,  показано на фиг.2, ще даде съвсем погрешен резултат [1], ако търговският пътник  тръгне от точката, отбелязана с 0. Числата на фигурата съответстват на  разстоянията в дясно и лявоот точката 0. Следвайки описания алгоритъм,  търговският пътник ще прескг надясно и наляво през пункта, от който е тръгнал.  Така ще измине път с дължи 93.6 единици. </p>
              <div class="style7">
                
                <img src="images/index_image006.gif" alt="image6" width="335" height="67" hspace="12" align="center" /></div>
             <p class="style7">Фиг.2. Контрапример на идеята за най-близкия  съсед </p>
              <p class="style7">За същата конфигурация Р от фиг.2, пътят показан на фиг.З е значително  по-къc (72.0). Всъщност той е и оптималният.</p>
              
                <img src="images/index_image008.gif" alt="image8" width="337" height="45" hspace="12" align="left" /> </p>
              <p class="style7">&nbsp;</p>
              <p class="style7">Фиг.З. Най-късият  път  за конфигурацията от фиг.2. </p>
              <p class="style7">Описанието  на един алгоритъм служи не само за това той да се изпълни от компютър. Често  описанията, особено на псевдокод, служат за обмен на идеи между хората. Поради  това описанието на един алгоритъм трябва да е леко  за четене. Методите за решение на дадена формализирана задача постоянно  се развиват и усъвършенстват. Поради това, един алгоритъм трябва да е  разработен така, че да подлежи на модификация  на онези негови елементи, за които са създадени нови методи. </p>
              <h3 class="blue">Структурно  програмиране </h3>
              <p class="style7"><br />
                Един  подход, който помага в голяма степен да се разработи правилен, лек за четене и  удобен за модификация алгоритъм, е този на структурното  програмиране. Структурното програмиране може да се разглежда като средство  на процедурното програмиране,  една от основните програмни парадигми (концептуални модели), наред с  обектно-ориентираното, функционалното или логическото програмиране. <br />
                В  основата на структурното програмиране стои една теорема, която се свързва с  имената на B&ouml;hm и  Jacopini. Тя гласи: три управляващи структури - последователност, избор  на алтернатива и итерация - са достатъчни за описаниетo на кой да е алгоритъм.  Тук явно не се споменава управляващата структура преход (go  to) и структурното програмиране е известно още като програмиране без  go to. <br />
                Сега  със средствата на блок-схемите от една страна и съответстващите им записи на  псевдокод от друга, ще представим всяка една от тези управляващи структури. </p>
              <p class="style7"><br />
                Последователност <br />
                <img width="102" height="134" src="images/index_image010.jpg" align="left" hspace="36" alt="image10" /></p>
              <p class="style7">                                                                           <br />
                ...;  S1; S2; . <br />
              </p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <p class="style7">Тук  под S1,S2 имаме предвид по-общо  или по-детайлно описание на изчислението на някаква функция. Затова такъв  правоъгълник, който характеризира с един вход  и един изход, се нарича функционален  блок. </p>
              <p class="style7"><br />
                <img width="197" height="179" src="images/index_image012.jpg" alt="image12" /></p>
              <div class="style7">
                <h4><em>ако В, то S1;</em><br />
                <em>иначе S2;</em></h4>
                <h4><span class="blue"> &nbsp;Избор на алтернатива
                                                                                                                                                                                                                                                                                                            </span><span class="blue">        </span>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </h4>
              </div>
              <p class="style7">Действието  на тази структура е известно: изчислява се условието В  и според това дали е изпълнено (случай t, true) или не е (случай f,  false) се изпълнява или  функционален блок S1,  или функционален блок S2  съответно. В записа на псевдокод са въведени "служебни думи": ако, то. иначе  с ясен смисъл и като разделители между условието и двата функционални блока.  Важно е да се отбележи, че вместо усложняване на записа със служебни думи за начало  (begin) и  кРай  (cud), двете отделни клаузи, за истина и лъжа, се записват с отстъп  надясно зад една вертикална черта. Така е видно докъде се простират клаузите  истина и лъжа. Също така е важно да отбележим смисъла на пунктирната линия в  блок- схемата:  конструкция избор на алтернатива може да се разглежда като функционален блок с един  вход и един изход.<br />
                Често се използва и кратката  форма на избор в ситуацияр когато действие се предприема само в случай на  истина на условието В.<br />
  <img width="250" height="188" src="images/index_image014.gif" align="left" hspace="150" alt="image14" />            </p>
              <p class="style7">&nbsp; </p>
              <div class="style7">
                <p><em><u>ако</u></em> B, <em><u>то</u></em> S;</p>
              </div>
                
              </p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <span class="style7"><br clear="all" />
              </span>
              <p class="style7">Относно итерациятя е уместно  разглеждането на два типа итеративни повторения: итеративен цикъл с предусловие  и такъв с постусловие.</p>
              <p class="style7"><br />
                Итеративен цикъл с предусловие<br />
                <img src="images/index_image016.gif" alt="image16" width="180" height="194" hspace="150" align="left" /> <br />
                <em><u>докато</u>B <u>прави</u> S;</em></p>
              <p class="style7"><em>&nbsp;</em></p>
              <p class="style7"><em>&nbsp;</em></p>
              <p class="style7"><em>&nbsp;</em></p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
				<p class="style7">Тук условието <em>В</em> за това дали се повтаря тялото на цикъла <em>S </em>се  проверява на входа. Поради това е възможно тялото да не се изпълни нито веднъж. </p>
              <p class="style7">Итеративен цикъл с постусловие</p>
              <p class="style7"><br />
                  <img width="154" height="219" src="images/index_image018.jpg" align="left" hspace="150" alt="image18" /> <br />
                повтаряй S; <br />
                докато В; </p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <p class="style7">Тук  безусловно се влиза в тялото на цикъла и едва след първото му изпълнение се  проверява дали да се повтаря изпълнението му. <br />
                И  двата цикъла могат да се разглеждат като функционални блокове с един вход и  един изход. <br />
                Един  частен случай на цикъл с предусловие, който се използва, когато предварително е  известен броят повторения на тялото, е цикъл с изброяване (for) за ieP  прави 5; ' <br />
                което  означава, че за стойности на управляващата променлива на цикъла i от едно известно множество Р  се повтаря изпълнението на тялото S. <br />
                Както отбелязахме по-горе, тези управляващи структури са  достатъчни за описанието на кой да е алгоритъм. Полезно е обаче добавянето на  още една структура: избор на една от много възможности, която иначе може да  бъде реализирана с поредица структури ако  то иначе: </p>
              <p class="style7"><br />
                <img width="235" height="130" src="images/index_image020.jpg" align="left" hspace="7" alt="image20" /><u>Ст</u>руктура  превключвател<u>:</u> <br />
                Вариант от <em>i</em><br />
                1:<em> S</em>1<em>;</em><br />
                2:<em>S</em>2<em>;</em><br />
                <em>....</em><br />
                n:<em> Sn;</em></p>
              <p class="style7"><em>&nbsp;</em></p>
              <p class="style7"><em>&nbsp;</em></p>
              <p class="style7">Съществено  е, че и тази структура може да се разглежда като функционален блок с един вход  и един изход. </p>
              <p class="style7">Използване  на goto <br />
              Както  отбелязахме, структурното програмиране е известно като програмиране без  използван на преход. Това обаче не  следва да се възприема като догма. Понякога е полезно използването на преход,  например за принудително напускане на тялото на цикъл при достигане на условие,  което не може да бъде изчислено преди входа в цикъла. Следният алгоритъм за двоично  търсене илюстрира това, за да се избегне излишното повторение на тялото, ако  елементът с ключ х  е открит. </p>
              <p class="style7"><br />
                <em>i;=1;j;=n;</em><br />
                <em><u>докатo</u> i&lt;=j <u>прави</u></em> <br />
                <em>	m:=(i=j)/2;</em><br />
                <em><u>ако</u>A[m]=x <u>то</u></em> <br />
                <em><u>преход  към</u> found;</em><br />
                <em><u>ако</u>x&gt; A[m] <u>то</u></em> <br />
                <em>i:=m;</em><br />
                <em><u>иначе</u></em> <br />
                <em>j:=m;</em><br />
                <em>found:</em></p>
              <p class="style7">Разбира  се, същият алгоритъм, с допълнителни средства, може да се опише и без преход.</p>
              <p class="style7"> <br />
                flag:=false; i:=l;j:=n; <br />
                докато i&lt;=j and not flag прави <br />
                m:=(i+j)/2; <br />
                <em><u>ако</u> A[m]=x <u>то</u></em> <br />
                flag: =true;<br />
                <em><u>иначе</u></em> <br />
                <em><u>ако</u> x&gt; A[m] <u>то</u></em> <br />
                <em>i:=m;</em><br />
                <em><u>иначе</u></em> <br />
                <em>j:=m;</em></p>
              <p class="style7"><br />
                Така обаче алгоритъмът става по-дълъг и  трябва да се обяснява смисълът на булевата променлива flag<br />
                Изброените  управляващи структури се характеризират с основно свойство - един вход и един  изход и още се наричат структурни блок схеми.  Алгоритъм, който е разработен с използване само на структурни блок-схеми и  самият има един вход и един изход, се нарича структурен  алгоритъм. <br />
                Това  свойство на структурните алгоритми се използва от основния метод в структурното  програмиране - програмиране отгоре-надолу (top-down).  Същността на този метод се състои в разработка на алгоритъма  на стъпки, като на всяка стъпка един функционален блок се заменя с по-детайлна  структура. Детайлизацията на всяка стъпка се извършва с използване само на  структурни блок-схеми. Детайлизацията продължава дотогава, докато се достигне  ниво, по което за алгоритъма може да се напише програма.</p>
              <p class="style7">Например  да разработим алгоритъм, който реализира функцията <em>f</em>.  Нека тази функция може да се разложи на композиция от други две функции g и h, т.е.  f(d) =  g(h(d)). Функцията <em>f</em> ще бъде правилно  реализирана, ако се реализират правилно функциите <em>g </em>и <em>h.</em></p>
              <p class="style7"><br />
                  <img width="237" height="135" src="images/index_image022.jpg" align="left" hspace="250" alt="image22" /> </p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <p class="style7">Нека сега съсредоточим  вниманието си върху една от функциите, например g. Да приемем, че тя може  да се реализира със следната структура </p>
              <p class="style7"><img width="295" height="143" src="images/index_image024.jpg" align="left" hspace="250" alt="image24" /></p>
              <p class="style7">&nbsp; </p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <p class="style7">&nbsp;</p>
              <p class="style7">Тогава,  ако алгоритмите <em>&#945;</em> и &#946;  саправилно построени,  следва правилната реализация и на g. Следователно  структурното програмиране отгоре-надолу се състои в това: на всяка стъпка да се  пита може ли функцията, представена с даден блок, да се декомпозира, т.е. да се  представи като композиция на други две или повече по-прости функции, чиято  реализация е със структурни блок-схеми. При тази декомпозиция се заменя един  функционален блок с по-детайлна схема, която пак има един вход и един изход.  Ясно е защо структурното програмиране ползва само структурни блок-схеми. </p>
              <p align="right" class="style7"><img width="391" height="160" src="images/index_image026.jpg" align="left" hspace="250" alt="image26" /></p>
              <p align="right" class="style7">&nbsp;</p>
            
              <p align="center" class="style7">Фиг.4.  Труден за четене и модификация алгоритъм във вид на спагети </p>
              <p class="style7">Какви са предимствата на структурното програмиране: </p>
              <ol>
                <li class="style7">на всяка стъпка на детайлизация съсредоточаваме вниманието си  само върху един функционален блок; правилната му замяна с по- детайлна схема в  голяма степен гарантира правилността на целия алгоритъм; </li>
                <li class="style7">един алгоритъм, съставен по този начин, се чете леко, тъй  като има дървовидна структура (фиг.З), а не такава на граф с множество цикли, или  както се казва, вид на спагети (фиг.4); </li>
                <li class="style7">в голяма степен се гарантира правилността на съставения  алгоритъм; ако на поредната стъпка на детайлизация се покаже, че g правилно се декомпозира чрез показаната по-горе структура и а  и /? са правилно построени, то е правилна и замяната на g чрез тази структура; </li>
                <li class="style7">по-лесно се осъществява модификация; ако трябва да се  модифицира g,  заменя се само онзи функционален блок, който я реализира, без това да се  отразява на останалата част на алгоритъма. </li>
              </ol>
      </div>
     <a style="display:scroll;position:fixed;bottom:10px;right:10px;" href="#" title="В началото"><img width="30" height="30" src="images/button.png"/></a>       
</div>
	
<div id="footer">
			<p>&copy; Copyright Synthesis and Analysis of Algorithms &middot; 2017 &middot; Design: Elitsa Nikolova&middot; 
			 
			  <a href="index.html"><span>Алгоритми</span></a>&middot;
              <a href="struct.html"><span>Структури данни</span></a>&middot;
               <a href="metods.html"><span>Методи за създаване</span></a>&middot;
               <a href="sort.html"><span>Алгоритми за сортиране</span></a>&middot;
		    <a href="map.html"><span>Карта на сайта</span></a></p>
</div>



</body>
</html>