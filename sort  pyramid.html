<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-5" />
	<meta name="Author" content="Elitsa Nikolova" />
	<meta name="Robots" content="index,follow" />
	<meta name="Description" content="Synthesis and Analysis of Algorithms" />
	<meta name="Keywords" content="Synthesis,Analysis,Algorithms" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<title>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</title>
    <style type="text/css">
<!--
.style1 {
	font-size: 1.2em;
	color: #333333;
}
.style7 {font-size: 1.2em}
.style13 {font-size: 0.7em}
-->
    </style>
</head>
<body>
	<div id="main">
<ul id="menu">
<li><a href="sort.html"><span class="key">Алгоритми за сортиране</span></a></li>
            <li><a href="metods.html"><span class="key">Методи за създаване</span></a></li>
            <li><a href="struct.html"><span class="key">Структури данни</span></a></li>
            <li><a href="struct.html"><span class="key">Алгоритми</span></a></li>
</ul>
		
  <div id="intro_left">
			<p>Алгоритмите в сайта са описани на псевдокод, което ги прави по-лесни за четене и разбиране.</p>
	  </div>
		
		<div id="intro_right">
			<p class="white">УЕБ БАЗИРАНО ПРИЛОЖЕНИЕ ПО</p>
		  <h1>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</h1>
			<p></p>
		</div>

  <ul id="menu_left">
			<li><a href="sort quick.html"><span>Бързо сортиране</span></a></li>
			<li><a href="sort merge.html"><span>Сортиране чрез сливане</span></a></li>
			<li><a href="sort  pyramid.html"><span>Сортиране чрез дърво. Пирамидално сортиране</span></a></li>
            <li><a href="sort no comparison.html"><span>Сортировка без сравнения</span></a></li>
		<li><a href="task04.html"><span>Задачи</span></a></li>
	  </ul>


			<div class="special">
			  <h1>Сортиране чрез дърво. Пирамидално сортиране 
			  </h1>
			  <p>Задачата  е да се сортира линейна последователност от елементи във възходящ ред.  Следователно става въпрос не за представяне на елементите с дървовидна  структура, например двоично дърво на търсене, а за използване на дървото като  помощно средство за сортиране на линейна структура. <br />
			    Един  от разгледаните базови методи за сортиране, този с пряка селекция, се базира на  последователно избиране на най-малък елемент измежду п  елемента, измежду п-1  елемента и т.н., което води към брой сравнения от порядъка на и2.  Тази оценка може да се подобри, ако при едно сканиране на редицата за  определяне на минимален елемент се запази повече информация за съотношението на  останалите елементи, а не само идентификация на най-малкия. <br />
			    Например  да разгледаме следния масив от елементи <br />
			    44,  55, 12, 42, 94, 8, 6, 67 <br />
			    и за него да построим  следното "дърво на селекцията": </p>
			  <br clear="all" />
              <div>
                <p align="center"><img src="images/sort  pyramid_image002.gif" alt="2" width="413" height="236" /> </p>
              </div>
              <br clear="all" />
              <div>
                <p>С <img src="images/sort  pyramid_image004.gif" alt="4" width="13" height="25" />сравнения  може да се определи по-малкият от всяка двойка елементи; с <img src="images/sort  pyramid_image006.gif" alt="6" width="13" height="25" /> сравнения  може да се определи най-малкият от всеки две двойки елементи и т.н. Горното  дърво, коренът на което е най-малкият елемент от всички, може да се построи със  следния брой сравнения:</p>
                <p><img src="images/sort  pyramid_image008.gif" alt="8" width="110" height="25" />където <img src="images/sort  pyramid_image010.gif" alt="10" width="120" height="25" /><br />
                  S = <em>n</em> - 1<br />
                </p>
              </div>
              <br clear="all" />
              <div>
                <p>Следователно  построяването на дърво на селекцията изисква n-1  сравнения. С това е определен най-малкият  елемент, но е запазена и информация за съотношението на останалите елементи в  редицата. След построяването на това дърво, за извеждане на елементите на  редицата в сортиран вид може да се изпълнят следните стъпки: </p>
                <ol>
                  <li>най-малкият елемент е в корена на дървото; той се извежда, а  мястото му се заменя условно с &quot;&#8734;&quot;; </li>
                  <li>слиза се по "пътя" на този елемент до "дъното", като там  елементът се заменя с &quot;&#8734;&quot;; този път е с дължина log2  п; </li>
                  <li>осъществява се едно изкачване до корена, като на междинните  нива отстраненият елемент се заменя с по-малкия от съответните два елемента;  изкачването изисква също log2 п  сравнения; </li>
                  <li>в корена на дървото се е появил новият най-малък елемент и с  него се повтарят описаните действия. </li>
                </ol>
                <p>По  този начин последователно се извеждат елементите по реда на селекцията, но с  по-малко операции; след построяването на дървото на селекция с<em>n</em>-1  сравнения, за всеки от п -те  елемента се правят 2log2 п  сравнения. Следователно общият брой сравнения е <br />
                    <img src="images/sort  pyramid_image012.gif" alt="12" width="278" height="19" /> <br />
                  Подобряване  на сложността на такъв подход за сортиране идва от увеличеното количество  информация, натрупано от първото преминаване, водещо до формиране на  дървовидната структура. <br />
                  Този  подход си има и някои неудобства. От една страна, трябва по подходящ начин да  се представят "дупките" в дървото, заменяни с условното а от друга страна, за  съхранение на натрупаната информация се използва повече памет. Така за  сортиране на п елемента се  използват <br />
                  <img src="images/sort  pyramid_image014.gif" alt="14" width="233" height="33" /><br />
                  места за елементите на  дървото на селекция. <br />
                  Проблемът,  който възниква, е, как да се използват предимствата на структурата дърво, така  че <em>п </em>елемента да се сортират с използване на <em>n</em> единици памет, т.е. да се  осъществи &quot;сортиране на място&quot;. Една такава възможност за сортиране  на място се оказва използването на структурата <em>пирамида. </em><br />
                  <em>Пирамида </em>се  нарича двоично дърво с <em>h </em>нива, което притежава следните <br />
                  свойства: </p>
                <ol>
                  <li>всеки  лист има височина <em>h </em>или <em>h </em>-1 ; </li>
                  <li>всеки лист с височина <em>h </em>е наляво от  кой да е лист с височина <em>h-1; </em></li>
                  <li>стойността на елемента във всеки връх е  по-голяма от стойностите на </li>
                </ol>
                <p>елементите, които  следват след него. <br />
                  От (3)  следва, че най-големият елемент е в корена на пирамидата. От (1) и (2) следва,  че пирамидата е запълнено двоично дърво, за което видяхме, че може да се  линеаризира (да се представи в линейна последователност) по правилата за пълно  дърво. Тези правила накратко могат да се резюмират така. Връх, разположен в  елемент от редицата <em>a</em><em>i, </em>има наследници съответно в елементите <em>а2</em><em>i; </em>и <em>a2i+</em><em>1. </em>Ако за дадено <em>i,  2i </em>&gt; <em>n </em>, то елементът <em>а</em><em>i </em>няма  наследници. <br />
                  Тогава,  нека да приемем, че в масива, който трябва да сортираме, имаме пирамида.  Сортирането може да се осъществи така: </p>
                <ol>
                  <li>Тъй като в корена е най-големият елемент, то го  разменяме с последния елемент в редицата; </li>
                  <li>Установяваме<em>n</em>:=<em>n</em> -  1; </li>
                  <li>Полученото  дърво с <em>п </em>-1 елемента  преобразуваме в пирамида; само първият елемент (коренът) нарушава правилата за  пирамида, придвижваме го надолу по дървото до място, в което е по-голям от  двата си наследника; </li>
                  <li>Повтаряме стъпки 1, 2 и 3 докато стане <em>п </em>= 1  . </li>
                </ol>
                <p>Тъй като това сортиране предполага още в началното състояние  да се тръгне от пирамида, то стъпка 3 се прилага предварително за всички  елементи, които имат наследници. <br />
                  Да  опишем стъпка 3 за елемент със индекс<em>l</em> в  редицата при следните предпоставки: поддърветата, които са наследници на възела  с номер <em>l</em> са пирамиди; само този възел нарушава пирамидалността според  изискването 3 за пирамида и на него трябва да се намери подходящо място в  дървото, което започва от него. <br />
                  <em>алгоритъм heap(a,l,n) </em><br />
                  <em>i:= </em><em>l; j:= 2i; х:= а</em><em>l; </em><br />
                  <em><u>докато</u> j </em>&lt;= <em>п <u>прави</u></em><em><u> </u></em><br />
                  <em><u>ако</u></em><em> j </em>&lt; <em>п and aj </em>&lt; <em>aj+1 <u>то</u> j:= j </em>+ 1; <br />
                  <em><u>ако</u></em><em> х</em>&gt; <em>aj</em> <em><u>то</u></em><em> <u>преход към</u> оиt; </em><br />
                  <em>ai:= aj;  i:= j; </em><em>j</em><em>=  2i;</em><br />
                  <em>out:ai:=x;</em><br />
                  Анализът на сложността на алгоритъма <em>heap </em>показва, че  итеративният цикъл в него ще се изпълнява докато от възела с номер в редицата <em>l </em>се стигне в най-лошия случай до лист.  Отново в най-лошия случай това ще е движение от корена до лист при <em>l </em>= 1, като е известно, че този път има  дължина log2 <em>п . </em>Следователно  сложността на <em>heap </em>е <em>O(log</em><em> n). </em>Сега може да опишем алгоритъма за сортиране с използване на  процедурата <em>heap. </em>Първоначално се започва с едно предварително  построяване на пирамида, като се прилага алгоритъмът <em>heap </em>за всички  елементи, които имат наследници. <br />
                  Това са елементите с  номера от 1 до <img src="images/sort  pyramid_image016.gif" alt="16" width="19" height="29" />. След това се следва  описаната по-горе поредица от стъпки. <br />
                  <em>алгоритъм  heapsort(a,n); </em><br />
                  <em>{първоначално  построяване на пирамида} </em><br />
                  <em>l:= п div 2; </em><br />
                  <em><u>докато</u> l </em>&gt;= <em>1</em> <em><u>прави</u> </em><br />
                  <em>heap(a,l,n); </em><br />
                  <em>l :=</em><em>l-1; </em><br />
                  <em>{сортиране} </em><br />
                  <em>т</em><em>:= l</em><br />
                  <em><u>докато</u> т&gt; </em>1 <em><u>прави</u></em><em><u> </u></em><br />
                  <em>r:=am; am:=a1;  a1:=r;<u></u></em><br />
                  <em>m:=m-l;  heap(a,l,m); </em><br />
                  Анализът  на сложността на този алгоритъм показва, че първоначално за <img src="images/sort  pyramid_image018.gif" alt="18" width="8" height="25" />елемента  се прилага алгоритъмът <em>heap, </em>а след това за всеки от <em>п </em>-те  елемента отново се прилага този алгоритъм за намаляващ брой елементи.  Следователно горна граница за сложността е оценката <br />
                  <img src="images/sort  pyramid_image020.gif" alt="20" width="249" height="33" /> </p>
              </div>
              <h1>&nbsp;</h1>
	  </div>
	   <a style="display:scroll;position:fixed;bottom:10px;right:10px;" href="#" title="В началото"><img width="30" height="30" src="images/button.png"/></a>  
</div>
	
<div id="footer">
			<p>&copy; Copyright Synthesis and Analysis of Algorithms &middot; 2017 &middot; Design: Elitsa Nikolova&middot; 
			 
			  <a href="index.html"><span>Алгоритми</span></a>&middot;
              <a href="struct.html"><span>Структури данни</span></a>&middot;
               <a href="metods.html"><span>Методи за създаване</span></a>&middot;
               <a href="sort.html"><span>Алгоритми за сортиране</span></a>&middot;
		    <a href="map.html"><span>Карта на сайта</span></a></p>
</div>
</body>
</html>