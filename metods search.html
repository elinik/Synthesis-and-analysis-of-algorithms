<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-5" />
	<meta name="Author" content="Elitsa Nikolova" />
	<meta name="Robots" content="index,follow" />
	<meta name="Description" content="Synthesis and Analysis of Algorithms" />
	<meta name="Keywords" content="Synthesis,Analysis,Algorithms" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<title>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</title>
    <style type="text/css">
<!--
.style1 {
	font-size: 1.2em;
	color: #333333;
}
.style7 {font-size: 1.2em}
.style13 {font-size: 0.7em}
-->
    </style>
</head>
<body>
	<div id="main">
<ul id="menu">
<li><a href="sort.html"><span class="key">Алгоритми за сортиране</span></a></li>
            <li><a href="metods.html"><span class="key">Методи за създаване</span></a></li>
            <li><a href="struct.html"><span class="key">Структури данни</span></a></li>
            <li><a href="struct.html"><span class="key">Алгоритми</span></a></li>
</ul>
		
  <div id="intro_left">
			<p>Алгоритмите в сайта са описани на псевдокод, което ги прави по-лесни за четене и разбиране.</p>
	  </div>
		
		<div id="intro_right">
			<p class="white">УЕБ БАЗИРАНО ПРИЛОЖЕНИЕ ПО</p>
		  <h1>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</h1>
			<p></p>
		</div>

	  <ul id="menu_left">
		<li><a href="metods private.html"><span>Метод на частните цели</span></a></li>
		<li><a href="metods evristic.html"><span>Евристични алгоритми</span></a></li>
		<li><a href="metods search.html"><span>Изчерпващо търсене с възврат</span></a></li>
        <li><a href="metods dyn.html"><span>Метод на динамичното програмиране</span></a></li>
		<li><a href="task03.html"><span>Задачи</span></a></li>
	  </ul>


			<div class="special">
			  <h1> Изчерпващо търсене с  възврат (Backtracking) </h1>
			  <p>В търсенето на фундаментални  принципи за построяване на алгоритми, изчерпващото търсене с възврат представя  един от най-общите подходи за комбинаторни задачи. Да припомним, че  комбинаторни задачи са тези, при които сред елементите на едно крайно множество  се търсят един или повече елементи, удовлетворяващи  някакво условие.</p>
			  <p> Тъй като &quot;крайно&quot; обикновено съвсем не означава  &quot;малко&quot;, за комбинаторните задачи, даже които просто се формулират, е  характерно това, че имат да преравят огромно количество варианти - елементи на  изследваното множество. <br />
			    В  основата на алгоритмите за решение на такива задачи стоят процедури за  пораждане на елементите на изследваното множество, проверка на условията и  отделяне, изреждане или преброяване на елементите, удовлетворяващи тези условия. <br />
			    За да се  приложи подходът backtracking, желаното решение на задачата трябва да е  представимо като <em>n</em>-торка <em>(</em><em>x1,  x2, x3, ., xn</em><em>), </em>където всяко <em>Xi </em>се  избира от едно крайно множество <em>Si</em><em>.</em>Често задачата, която трябва да  се реши, е формулирана така, че се търси такава <em>п </em>-торка, компонентите  на която удовлетворяват някакъв критерий <em>P</em>(<em>x1,  x2, x3, ., xn</em><em>)</em><em>.</em> Например в задачата на търговския пътник решението <em>(</em><em>x1,  x2, x3, ., xn</em><em>) </em>е една пермутация на числата от 1  до <em>п , </em>а критерият <em>Р </em>е сумата от цените на преходите между  последователните елементи на пермутацията, като изискването е да се намери  онази пермутация, която минимизира тази цена. <br />
			    Да предположим, че <em>rn; </em>е размерът на множеството <em>Si </em>(броят  на елементите му). Тогава общият  брой <em>п </em>-торки, които са потенциални кандидати за решение, е <br />
                <img src="images/metods search_image002.gif" alt="2" width="180" height="52" /> <br />
                Един подход на &quot;бруталната  сила&quot; би бил да се генерират всички тези <em>m n </em>- торки и за всяка да се изчислява  критерият <em>Р, </em>запазвайки онези,  които водят до оптимум. <br />
                Подходът  backtracking има това свойство, че води към точното решение с евентуално значително по-малко от <em>m</em>опита. Основната идея се състои в  това: <em>n </em>-  торката на решението се изгражда компонента по компонента и се използват  модифицирани критериални функции <em>P</em><em>i</em>(<em>x1,  x2, ., xi</em><em>)</em><em>, </em>понякога  наричани ограничаващи функции. Проверката на тези функции показва дали текущо  формираният вектор има шанс да доведе до решение. Предимството на идеята е в  това, че ако функцията<em> P</em><em>i </em>покаже,  че векторът (<em>x1, x2, ., xi</em><em>)</em>няма шанс да доведе до <br />
                оптимално решение, то тогава няма  да се генерират <em>т</em><em>i+1</em><em>mi+2.mn</em>на брой <em>n </em>-торки, които  имат същите (<em>x1, x2, ., xi</em><em>)</em>първи компоненти. <br />
                За илюстрация на тази идея да  разгледаме следната задача за велосипедния катинар [2]. Имаме комбинационен  катинар, състоящ се от <em>п </em>превключвателя, всеки от които може да бъде в  две възможни състояния: включено или изключено (1 или О). Катинарът се отключва само при една комбинация на <em>n </em>-  те ключа, като не по-малко от <img src="images/metods search_image004.gif" alt="4" width="19" height="29" /> ключа са в състояние 1 (включено). Да допуснем, че сме  забравили отключващата комбинация и трябва да я открием. <br />
                Тук трябва да  отбележим следното. В този случай не е възможно да приложим евристичен  алгоритъм в опита си да намалим пространството на търсене с общ брой елементи 2<em>n</em>. Това е така, защото по  принцип евристичният алгоритъм не гарантира получаване на точното решение, а в  нашия случай понятието приближено решение няма смисъл. Дадена комбинация или е отключващата,  или не върши работа. <br />
                Онова, което е нужно  преди всичко, е алгоритъм, който систематично (без торения или пропуски)  генерира възможните комбинации. Търсеното решение представяме като n - торка <br />
                <img src="images/metods search_image006.gif" alt="6" width="93" height="19" />, като <img src="images/metods search_image008.gif" alt="8" width="88" height="32" /> <br />
                Формирането  на <em>n</em> -торката компонента по  компонента може да се представи като обхождането на едно дърво, в случая  двоично, а множеството на всички възможни n - торки - като листата в него. <br />
                Да разгледаме това  дърво в случая на<em> n</em>=4. Всяко ниво <em>k</em>=1,2,3,4 отговаря на избор на стойност  на <em>k</em> -тата компонента на вектора на  решението, докато в множеството <em>Sk</em> има неизползвани възможни стойности. Стрелките сочат посоката на движение: ако  за дадена компонента избраната стойност е допустима, движението е надолу (към  следващата компонента); ако стойността не е допустима, се избира нова стойност  за същата компонента и движението е надясно; ако са изчерпани всички възможни  стойности на това ниво, се осъществява връщане на предходното ниво и движението  е нагоре. Наличието на допълнително условие, отключващата комбинация да има не  по-малко от две единици, позволява да се избегне генерирането и проверката на дадени комбинации  (заградените с пунктир на фигурата). </p>
			  <p><img width="428" height="174" src="images/metods search_image010.jpg" alt="10" /><br clear="all" />
                  <br />
			    За  конкретната задача, едно от листата на дървото е отключващата комбинация;  след нейното откриване може да се прекрати генерирането следващи комбинации. В  общия случай обаче задачата може изисква определяне  на всички решения, които удовлетворяват критериалната <em>P</em>(<em>x1,  x2, ., xi</em><em>).</em>Тогава  обходът на дървото следва да продължи до пълното му изчерпване. <br />
			    Много от задачите, подлежащи на решаване с подхода  backtracking изискват  решението да удовлетворява комплекс от условия. Тези услови се разделят на две  категории: явни и неявни. <em>Явните </em>условия са такива, които ограничават  всяко <em>xi</em>да приема  стойности от зададено множество <em>S</em><em>i</em> . За катинара това е <img src="images/metods search_image012.gif" alt="12" width="55" height="32" />. Неявните условия определят дали една стойност на <img src="images/metods search_image014.gif" alt="14" width="13" height="19" /> от <em>S</em><em>i</em> е допустима  в зависимост от стойностите на предходните компоненти (<em>x1,  x2, ., xi</em><em>-1</em><em>).</em>В задачата  за катинара неявно условие е поне половината ключове да са в състояние 1. <br />
			    Нека  приемем, че булевата функция <em>test(</em><em>x1, x2</em><em>, </em><em>.</em><em>,</em><em>xk) </em>проверява нвявните условия за допустимост на стойността <em>x</em><em>k</em>на <em>k </em>-тата  компонента. Тогава общия алгоритъм на метода на пълното изчерпване с възврат  може да бъде описан така:<br />
  </p>
			  <p><em>алгоритъм  bcktrck </em> <br />
                <em>k </em>:= 1; <em>формиране на</em><em> Sk</em><em>;</em><br />
                <em><u>докато</u></em><em> k </em>&gt; О <em><u>прави</u></em><br />
                <em><u>докато</u></em><em> Sk <u>&#8800;{ } </u></em><em><u>прави</u></em><em><u> </u></em><br />
                <em> {движение надясно} </em><br />
                <em>x</em><em>k</em><em> :=</em>min<em>Sk;Sk :=Sk </em><em>|x</em><em>k</em><em>; </em><br />
                <em><u>ако</u></em><em> test(</em><em>x1, x2</em><em>, </em><em>.</em><em>,</em><em>xk) <u>то</u></em><br />
                <em><u>ако</u></em><em> k=n <u>то</u></em><br />
                <em>извеждане на  решение (</em><em>x1, x2</em><em>, </em><em>.</em><em>,</em><em>xk)</em><br />
                <em><u>иначе</u></em><br />
                <em>k </em>:= <em>k </em>+  1; <em>{движение надолу} </em><br />
                <em>формиране на </em><em>Sk</em><em>;</em><br />
                <em>k:= k </em>-1; <em>{движение нагоре}. </em><br />
			    За да се реши конкретна задача с този общ алгоритъм, е  достатъчно да се придаде конкретен смисъл на компонентите на вектора <em>(</em><em>x1, x2</em><em>, </em><em>.</em><em>,</em><em>xk) </em>намножествата <em>Sk</em><em>, </em>на начина на избор на min<em>Sk </em>и на булевата <em>test(xpx2,  ... ,xk) </em>според конкретните условия на задачата (ограничаващите  функции). </p>
			  <p><u class="blue">Задача за<em> п </em>-те царици </u><br />
			    Задачата  е следната: да се определи максималният брой царици и положението им върху  шахматна дъска <em>п </em>х <em>п </em>така, че никои две от тях да не се бият. <br />
  <img src="images/metods search_image016.gif" alt="16" width="243" height="190" /> </p>
			  <p><u>Решение</u>: Да разгледаме шахматната дъска  на фигурата. Две царици се бият, ако са разположени в една и съща колона, в  един и същ ред и по диагонал. Следователно в една колона или ред не може да има  повече от една царица. Така максималният брой царици, които могат да се  разположат без да се бият една до друга, не може да надхвърля <em>п . </em><br />
			    За да  приложим метода ВТ, трябва да намерим представяне на търсеното решение във вид  на <em>п </em>-мерен вектор. Това може да стане така: тъй като в една колона не  може да има повече от една царица, с всяка <em>k</em>-та царица да свържем една колона  и съответно компонента <em>x</em><em>k</em><em>.</em>Стойността на компонентата <em>x</em><em>k</em>приемаме да показва реда, в който е  разположена <em>k </em>-та царица. Следователно всяко множество <em>Sk</em> измежду  елементите на което се избира <em>xk, </em>е <em>Sk</em>={1, 2, ., <em>n</em>}.<br />
			    Сега  трябва да определим как се избира минимален елемент от множеството и как се  извършват операциите отстраняване на избран елемент <em>Sk</em><em>|x</em><em>k</em> и проверка на това дали  множеството <em>Sk</em>е празно. Това можем да направим,  ако с всяка колона (царица) свържем елемент <em>rk </em>на един масив <em>r. </em>Следните операции върху елемента <em>rk </em>показват състоянието на множеството <em>Sk</em>:<br />
  <em>r</em><em>k</em>:=  1 =&gt; формиране на пълно множество <em>Sk</em><em>;</em><br />
  <em>x</em><em>k</em>:= <em>r</em><em>k</em>=&gt; избор на min<em>Sk</em><em> ; </em><br />
  <em>r</em><em>k</em>:= <em>r</em><em>k</em><em>+</em>1 =&gt; <em>Sk:  = </em><em>Sk</em><em>| x</em><em>k</em><em>;</em><br />
  <em>r</em><em>k</em> &gt;<em>n</em>   =&gt; <em>Sk </em>= { }<br />
			    Остава да обсъдим изчислението на  булевата функция <em>test(x1, ... ,xk), </em>която отразява неявните  условия на задачата:<em>k</em>-тата  царица да не бие никоя от вече разположените <em>k-1 </em>царици. Тази функция трябва да установи дали стойността <em>x</em><em>k</em>е допустима в зависимост от стойностите <em>x</em><em>i</em><em>,i=</em><em>1</em><em>,2, ... ,k-</em><em>1</em><em>. </em>Царицата  с номер <em>k </em>бие някоя <em>i</em>-та царица от предходните, ако е  разположена в същия ред, т.е. <em>xk </em>= <em>x</em><em>i</em>за някое <em>i </em><img src="images/metods search_image018.gif" alt="18" width="10" height="19" />{1, 2, ... , <em>k</em><em>-</em>1<strong>}, </strong>или ако <em>k </em>-тата  царица е в един и същ диагонал с някоя <em>i</em> -та  царица. Вижда се, че две царици са по диагонал, ако дължините на двете отсечки <em>k-i </em>и <img src="images/metods search_image020.gif" alt="20" width="59" height="19" /> са  равни, т.е, ако <em>k-i=</em><img src="images/metods search_image020_0000.gif" alt="200" width="59" height="19" /> за  някое <em>i </em><img src="images/metods search_image018_0000.gif" alt="180" width="10" height="19" />{1, 2, ... , <em>k</em><em>-</em>1<strong>}</strong><strong>.</strong>Тогава алгоритъмът на булевата  функция <em>test </em>ще изглежда така: <br />
  <em>функция test(x,k):  булева; </em><br />
  <em>test:= trие; </em><br />
  <em><u>за</u></em> <em>i</em>:=1 <em><u>до</u></em><em> k-</em>1<em><u> </u></em><em><u>прави </u></em><em><u> </u></em><br />
  <em><u>ако</u></em><em> xk </em>= <em>x</em><em>i</em><em>; <u>то</u> </em><br />
  <em>test:= false; </em><br />
  <em><u>ако</u></em><em> k-i=</em><img src="images/metods search_image020_0001.gif" alt="201" width="59" height="19" /> <em><u>то</u></em><br />
  <em>test:= false; </em><br />
			    С тези уточнения за конкретната  задача алгоритъмът ВТ за решението й ще изглежда  така: <br />
  <em>алгоритъм qиееns(n) </em><br />
  <em>k </em>:= 1; <em>rk </em>:= 1; <br />
  <em><u>докато</u></em><em> k </em>&gt; О <em><u>прави </u></em><br />
  <em><u>докато</u></em><em> rk </em>&lt;= <em>п <u>прави</u> </em><br />
  <em>x</em><em>k</em>:= <em>rk; rk </em>:= <em>rk </em>+ 1; <br />
  <em><u>ако</u></em><em> test(x,k) <u>то </u></em><br />
  <em><u>ако</u></em><em> k=n <u>то</u></em><br />
  <em>печат </em>( <em>x</em><em>1</em><em>, ... ,</em><em>x</em><em>n</em><em>);</em><br />
  <em><u>иначе</u></em><br />
  <em>k :=k+</em><em>1</em><em>; rk:= 1;</em><br />
  <em>k:=k-</em><em>1</em><em>; </em></p>
			  <p><img src="images/metods search_image022.gif" alt="22" width="150" height="129" /><img src="images/metods search_image024.gif" alt="24" width="151" height="129" /></p>
			  <p>Лесно  може да се установи, че за <em>п </em>= 3  задачата няма решение. За <em>п </em>= 4  се  получават  следните две разположения: </p>
			  <p><u class="blue">Задача за оцветяване на  географска карта </u><br />
		      Тази задача се формулира така: Зададена е област от  географска карта на <em>n </em>държави,  някои от които са свързани с обща граница. За всяка държава да се подбере подходящ цвят от <em>Ь </em>на брой различни цветове, така че държавите  с обща граница да са оцветени с различни цветове. Да се намерят всички възможни  такива оцветявания на зададената област. </p>
			
			  <p><img src="images/metods search_image026.jpg" alt="26" width="175" height="150" /><img src="images/metods search_image028.jpg" alt="28" width="159" height="150" /> </p>
			  <p>    а)                                                    б)<br />
			    Фиг.1 <br />
			    Не би  имало проблем, ако броят на цветовете, с които разполагаме, е не по­-малък от  броя на държавите. Задачата има смисъл, ако броят на цветовете е много по-малък  от броя на държавите. В този случай задачата често се поставя и така: да се  определи минималният брой цветове, с които могат да се оцветят държавите в  областта. За различни области минималният брой необходими цветове би бил  различен. Доказано е обаче, че 4 цвята са достатъчни за оцветяването на коя да  е карта. Отново, за да решим задачата, трябва да придадем конкретен смисъл на <em>n­-</em>мерния вектор на решението <em>(x1,  ... ,xk), </em>на  множествата <em>Sk</em><em>, </em>измежду стойностите на които се избират  компонентите <em>xk </em>и алгоритъма на булевата функция <em>test, </em>която  проверява неявните условия. <br />
			    След  опита, получен от предходната задача, сега е лесно да определим следното: на  всяка <em>k </em>-та държава от <em>п</em>-те такива отговаря компонента <em>xk </em>на вектора <em>(x1, ... ,xk)</em><em>;</em>стойността на <em>xk</em> показва избрания цвят, като например стойност 1 отговаря на червен, 2 - на  зелен, 3 - на жълт и 4 - на син цвят, т.е. <em>Sk</em> ={1, 2, 3, 4}. Както  отбелязахме, 4 цвята са достатъчни за  оцветяването на коя да е карта .. <br />
			    Неявното условия на задачата е  две държави, които имат обща граница да са оцветени с различни цветове. За да  се проверява това условие е необходима информация за това кои държави имат обща  граница и за тази информация е необходимо подходящо представяне. Това може да  направим така: на всяка от <em>п</em>-те държави (Фиг.1 а) да съпоставим възел от един  граф (Фиг.l.б); на държавите, които имат обща граница, съответства ребро, което  свързва двата съответни възела. А представянето на информацията за графа е вече  решена задача (виж TSP). На графа съпоставяме една квадратна матрица <em>Сnхn; </em>елементът <em>cij</em>има  стойност 1 ако съществува ребро между <em>i</em>-тия  и <em>j </em>тия възел и стойност 0 противния случай. (За целта и  булева матрица върши работа). Тогава булевата функция <em>test, </em>която  проверява неявните условия, ще изглежда така: <br />
  <em>функция test(k,x) </em>: <em>булева; </em><br />
  <em>test:=true;</em><br />
  <em><u>за </u></em> <em>i</em>:= 1; <em><u>до</u> </em><em>k </em>- 1; <em><u>прави</u></em><br />
  <em><u>ако</u></em><em>cki</em><em>&#8800;</em><em>0 </em><em>and </em><em>x</em><em>k</em><em> =</em><em>xi</em><em>; <u>то</u> </em><br />
  <em>test </em>:= <em>false; </em><br />
			    Както се вижда, за матрицата С е достатъчно  да се въведат само елементите под главния диагонал. <br />
			    Записването на алгоритъма ВТ за  решение на задачата не представлява вече проблем. Той в голяма степен повтаря  този за <em>п </em>-те царици с уговорката, че сега множествата <em>Sk</em>се състоят от 4 елемента. <br />
			    Ако целта е да се намери  минималният брой цветове, с които може да се оцвети дадена конфигурация от  държави, то като се въведе допълнителен параметър <em>b</em> - брой на допустимите цветове,  задачата може да се проиграе с <em>b</em> = 2,3,4. Минималният  брой цветове ще бъде най-малката стойност на <em>b</em>,за която е получено поне едно  решение. </p>
			  <p><span class="blue"><u>Оценка за сложност</u></span><br />
		      Алгоритъмът ВТ е алгоритъм на  пълно изчерпване. Той генерира всеки елемент на едно множество от потенциални  кандидати за решение, които за задачата за <em>п </em>-те царици са <em>n17 </em>, а за задачата за оцветяване на карта са 4n . Въпреки, че неявните условия  позволяват да се отхвърлят, без да се генерират, едно значително подмножество  на всички възможни <em>п </em>-торки, то алгоритъмът ВТ остава с експоненциална сложност. Това следва да се има предвид  при подбора на стойност на размерността <em>п </em>при тестването на програмите,  реализиращи двете задачи. </p>
			  <p><u class="blue">Задача за сума на подмножества </u><br />
		      Зададено е множество <em>W </em><em>=</em><em>{w1,w2,.,wn}</em> от  цели положителни числа цялото положително число <em>M</em>. Да се намерят всички  подмножества <em>T</em> <img src="metods search_image030.gif" alt="30" width="8" height="19" /> <em>W</em> такива, че сумата от елементите  им да е равна на <em>М, </em>т.е. </p>
			  <ol>
			    <li>      <img src="images/metods search_image032.gif" alt="32" width="93" height="21" /> </li>
		      </ol>
			  <p>Например, ако <em>W</em>={11,13,24,7}и <em>M</em>=31,то решенията са {11,13,7} и  {24,7}. Така  представени, решенията са с различен брой компоненти. Ако искаме директно следваме  изложения общ алгоритъм ВТ, трябва да намерим форма, в която всяко шение да се  представя с <em>п </em>-торка. Това може да направим така: всяко решение е <em>n</em>-торка (<em>x1,x2,.,xn</em>) като <br />
                  <img src="images/metods search_image034.gif" alt="34" width="112" height="36" /> <br />
			    Така векторът (<em>x1,x2,.,xn</em>) може да се разглежда като маска,  наложена над <em>W, </em>през  която се виждат само елементите, които участват в <em>Т. </em>Тогава основното условие на задачата (1) е да се намерят  всички решения <em>(</em>(<em>x1,x2,.,xn</em>), така че <br />
  <img src="images/metods search_image036.gif" alt="36" width="92" height="52" /> <br />
			    Броят на  всички възможни подмножества на <em>W </em>съвпада с броя на всички възможни <em>n</em>-торки (<em>x1,x2,.,xn</em>) от нули и единици, който е 2n. За да ограничим е малко  огромния брой <em>п </em>-торки, които следва да се генерират, като се отхвърлят  такива частични решения, които нямат шанс да доведат до решение, трябва да се  формулират ограничаващи (неявни) условия. С оглед да формулираме такива условия  нека приемем, че първоначално елементите на множествотоса <em>W</em> сортирани във  възходящ ред <br />
  <img src="images/metods search_image038.gif" alt="38" width="135" height="19" /> <br />
			    Тук могат  да се формулират два типа неявни условия: <br />
			    1. Ако за дадена стойност на <em>k </em>имаме <br />
			    (2)                                               <img src="images/metods search_image040.gif" alt="40" width="98" height="20" />,<br />
			    това означава, че сме намерили  решение <br />
			    (<em>x1</em>, <em>x2</em>, ., <em>xk</em>, 0, 0, ., 0) <br />
			    и  следващите след <em>k</em>-тата компоненти могат да бъдат само нулеви, за да не се  наруши равенството. <br />
			    2. Ако за  дадена стойност на <em>k </em>горното равенство (2) не е изпълнено, то следва да се провери дали формираното дотук  частично решение има шанс да доведе до решение. Ако поне едно от следните  неравенства е нарушено, то такъв с няма и съответните <em>п </em>-торки не трябва да се генерират: <br />
  <img src="images/metods search_image042.gif" alt="42" width="161" height="54" /> <br />
  <img src="images/metods search_image044.gif" alt="44" width="141" height="54" /> </p>
			  <p>&nbsp;</p>
			  <h1>&nbsp;</h1>
	  </div>
	   <a style="display:scroll;position:fixed;bottom:10px;right:10px;" href="#" title="В началото"><img width="30" height="30" src="images/button.png"/></a>  
</div>
	
<div id="footer">
			<p>&copy; Copyright Synthesis and Analysis of Algorithms &middot; 2017 &middot; Design: Elitsa Nikolova&middot; 
			 
			  <a href="index.html"><span>Алгоритми</span></a>&middot;
              <a href="struct.html"><span>Структури данни</span></a>&middot;
               <a href="metods.html"><span>Методи за създаване</span></a>&middot;
               <a href="sort.html"><span>Алгоритми за сортиране</span></a>&middot;
		    <a href="map.html"><span>Карта на сайта</span></a></p>
</div>
</body>
</html>