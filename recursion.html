<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-5" />
	<meta name="Author" content="Elitsa Nikolova" />
	<meta name="Robots" content="index,follow" />
	<meta name="Description" content="Synthesis and Analysis of Algorithms" />
	<meta name="Keywords" content="Synthesis,Analysis,Algorithms" />
	<link rel="stylesheet" type="text/css" href="style.css" />
	<title>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</title>
    <style type="text/css">
<!--
.style1 {
	font-size: 1.2em;
	color: #333333;
}
.style7 {font-size: 1.2em}
.style13 {font-size: 0.7em}
-->
    </style>
</head>
<body>
	<div id="main">
<ul id="menu">
<li><a href="sort.html"><span class="key">Алгоритми за сортиране</span></a></li>
            <li><a href="metods.html"><span class="key">Методи за създаване</span></a></li>
            <li><a href="struct.html"><span class="key">Структури данни</span></a></li>
            <li><a href="index.html"><span class="key">Алгоритми</a></li>
</ul>		
  <div id="intro_left">
			<p>Алгоритмите в сайта са описани на псевдокод, което ги прави по-лесни за четене и разбиране.</p>
	  </div>
		
		<div id="intro_right">
			<p class="white">УЕБ БАЗИРАНО ПРИЛОЖЕНИЕ ПО</p>
		  <h1>СИНТЕЗ И АНАЛИЗ НА АЛГОРИТМИ</h1>
			<p></p>
		</div>

<ul id="menu_left">
			<li><a href="index.html"><span>Алгоритми, изисквания, описание</span></a></li>
			<li><a href="analyses.html"><span>Анализ на алгоритми. Изчислителна сложност. Класификация</span></a></li>
		<li><a href="recursion.html"><span>Рекурсия</span></a></li>
		<li><a href="task01.html"><span>Задачи</span></a></li>
	  </ul>


			<div class="special">
			  <h1> Рекурсия</h1>
			  <p><br />
			    Рекурсията е често срещано явление, както в математиката,  така и в алгоритмите. Общо казано, рекурсивен е обект, в дефиницията на който  има позоваване на самия него. Обектът може да бъде понятие, например  математическо, функция, процедура, фигура. <br />
			    Рекурсивни  дефиниции на функции са често срещани в математиката. Прости примери за това са  функции на целочислен аргумент, наречени рекурентни  формули. Типичен пример за такава функция в n!.</p>
			  <table border="0" cellspacing="0" cellpadding="0">
                <tr>
                  <td valign="top"><p>Математическа <br />
                  дефиниция: </p></td>
                  <td valign="top"><p>Рекурсивна    функция: </p></td>
                </tr>
                <tr>
                  <td valign="top"><p>n!= n(n-1)! <br />
                  0! = 1 </p></td>
                  <td valign="top"><p>function fact(niinteger) .integer; <br />
                    begin <br />
                    if п=0 then <br />
                    fact:=1 <br />
                    else <br />
                    fact: =n *fact(n-l'); <br />
                  end; </p></td>
                </tr>
              </table>
			  <p>Съществено  е, че всяка рекурентна формула, за да бъде използваема, изисква стартова  (стартови) стойност. В случая с n! това  е 0!, която стойност се изчислява директно. Това намира отражение в съответната  част на рекурсивната функция, с която се реализира изчислението на n! (if п=0  then fact:=1). <br />
			    Така  в рекурсивната дефиниция на функцията fact са  налице трите елемента на кой да е рекурсивен алгоритъм: </p>
			  <ol>
			    <li>параметризация: определяне  на параметър (или параметри) на  задачата; това обикновено е размерността на задачата. При всяко рекурсивно  извикване този параметър се изменя така (намалява или расте), че да се  гарантира преминаване през тривиалния случай; </li>
			    <li>тривиален случай:  такъв, който се решава директно без рекурсивно извикване; този случай  съответства на стартовата стойност на рекурентната функция, ако се касае за  такава задача; </li>
			    <li>общ случай;  той се решава чрез едно или повече рекурсивни извиквания (в случая n*fact(n-1)). </li>
		      </ol>
			  <p>Един от недостатъците  на рекурсивните алгоритми е, че в общия случай те изискват значително повече  време за изпълнение от съответните итеративни алгоритми за същата задача.  Типичен случай за това е рекурсивната дефиниция за изчисление на числата на  Фибоначи. <br />
			    Числата  на Фибоначи се дефинират с рекурентната зависимост <br />
			    Fn  = Fn-1+ Fn-2, за  п&gt;2 и F0=F1= 1 <br />
			    Съответната рекурсивна  функция ще бъде: <br />
			    function  Fib(n: integer): integer; <br />
			    begin <br />
			    if n &lt; 1 then <br />
			    Fib := 1 <br />
			    else <br />
			    Fib := Fib(n -1) + Fib(n-2);</p>
			  <p>end; <br />
			    Недостатъкът  на рекурсивната дефиниция е, че Fib(n-1) и Fib(n-2) ще се изчисляват отделно, независимо, че при изчислението  на Fib(n-1) ще се мине и през изчисление на Fib(n- 2)  и останалите. <br />
			    Ако опитаме да пресметнем броя извиквания на Fib за  изчисление на Fn, ще  видим следната зависимост: да означим с <em>f</em>(<em>n</em>)  броя извиквания на функцията Fib за  определяне на Fn,  то тогава <em>f</em></a>(<em>n</em>) = <em>f</em>(<em>n  - 1</em>)   + <em>f</em>(<em>n  - 2</em>) <br />
			    когато  п  &#8805;  2, а при <em>n</em> = 0,1 е необходимо само по едно извикване, което минава през тривиалния случай.  Но това е точно дефиницията на число на Фибоначи, следователно <br />
			    f(n) =Fn. <br />
			    Една  проста сметка може да покаже, че колкото п  расте, толкова отношението на две съседни числа на Фибоначи се приближава до  числото &oslash;=  1.618033989..., наречено "златно сечение" <br />
  <img src="images/recursion_image002.gif" alt="23" width="65" height="39" /> </p>
			  <p>Оттук  следва <br />
			    <img src="images/recursion_image004.gif" alt="43" width="80" height="19" />= <img src="images/recursion_image006.gif" alt="63" width="48" height="19" /> = . = <img src="images/recursion_image008.gif" alt="83" width="18" height="19" /> <br />
			    Следователно <br />
			    f(n) = Fn=<img src="images/recursion_image008_0000.gif" alt="803" width="18" height="19" /> ,<br />
			    което  означава, че сложността на рекурсивния алгоритъм е експоненциално растяща,  защото &oslash; &gt;  1. Противно на това, съществува итеративен алгоритъм (от частния случай към  общия), който работи с линейна сложност O(п).  Този алгоритъм може да се разработи, като се обърне внимание на това, че за  изчислението на Fn са  нужни стойностите само на две предходни числа на Фибоначи, а не всички преди  него. <br />
			    function fib (п: integer) :integer; <br />
			    var f0,fl,f2,i:integer;<br />
			    begin <br />
			    if n&lt;=1  then <br />
			    fib:=1 <br />
			    else <br />
			    begin <br />
			    f0:=1; f1:=1; <br />
			    for i:=2 to n do <br />
			    begin f2: =f1 +f0; f0: =f1; f1:=f2; end; <br />
			    fib:=f2;<br />
			    end; <br />
			    end; <br />
			    Независимо  от това, че рекурсията често води към алгоритми, чиято ефективност не е особено  добра, тя е много полезно средство за построяване на алгоритми за редица  задачи. Като пример за това ще разгледаме следната <br />
			    <span class="blue">Задача за ханойската кула </span><br />
			    Става дума за следната игра: зададени са три оси А,В и С. На  първата ос са наредени п  пръстена в намаляващ ред на диаметрите им, така че най-малкият пръстен е на  върха. Задачата се състои в това, тези пръстени да се преместят на втората ос,  наредени в същия ред, с използване на третата ос като помощна, при спазване на  следните правила: </p>
			  <ol>
			    <li>на всеки ход се мести по един пръстен от върха на една ос на  друга; </li>
			    <li>пръстен може да се постави или на празна ос, или върху  пръстен с по- голям диаметър. </li>
		      </ol>
			  <p><img width="355" height="116" src="images/recursion_image010.jpg" alt="103" /></p>
			  <p>Алгоритъмът  за решаване на задачата трябва при всяко зададено п  да генерира ходовете за разиграване на играта. Лесно може да си представим  ходовете за разиграване на играта при п  = 1, п  = 2, дори при п = 3. Но е доста трудно да си представим директен алгоритъм  (без рекурсия) при произволно п. Тук  много полезна е възможността за използване на рекурсия за описание на ходовете  на играта. </p>
			  <p>Да си представим, че в опита си да изиграем играта с п  пръстена, можем да решим задачата за п-1  пръстена, спазвайки правилата. Тогава да преместим горните п-1  пръстена от А върху помощната ос С; върху А остава най-големият пръстен, който  с един ход преместваме върху В; отново използваме "възможността" да решим  задачата за п-1 пръстена, които местим  от С върху В. С това алгоритъмът изглежда така: <br />
			    алгоритъм hanoi(n,  А, В, С); <br />
			    ако  п = 1 то <br />
			    печат("мести от &quot;, А, &quot;върху ", В)<br />
			    иначе <br />
			    hanoi(n-1, A, C, B); <br />
			    печат("мести от &quot;, A, "върху ", В); <br />
			    hanoi(n-1,C,B,A)\ <br />
			    Това  очевидно е рекурсивен алгоритъм, който има трите необходими елемента: параметър  п - броят на пръстените;  тривиален (терминален) случай - решението на задачата при п  = 1, което е директно; общ случай, който се решава с две  рекурсивни извиквания и един директен ход. Тъй като езикът Паскал допуска  рекурсия, алгоритъмът директно може да се преведе в рекурсивна процедура на  Паскал: <br />
			    procedure Hanoi(n,A,B, С: integer); <br />
			    begin <br />
			    if (n=l) then <br />
			    writeln('Move the ring  from ',A, ' to ',B) <br />
			    else begin <br />
			    Hanoi(n-l, A, C, B); <br />
			    writeln('Move the ring  from ',A, ' to ',B) <br />
			    Hanoi(n-l, C, B, A); <br />
			    end; <br />
			    end; </p>
			  <h3 class="blue">Фрактали </h3>
			  <p><br />
			    По-горе отбелязахме, че рекурсивен е всеки обект, в  дефиницията на който става позоваване на самия него. Такъв обект може да бъде и  геометрична фигура. Такива фигури са така наречените фрактали. <br />
			    Формите, които срещаме в природата и традиционните  геометрични форми на математиката - сфери, конуси, елипсоиди, не винаги си  приличат. Основната разлика в тях е, че математическите форми са регулярни  (правилни), докато в природата липсва тази регулярност. На тази особеност, и  свързаните с нея, обръща внимание Беноа Манделброт в работата си "The  fractal geometry of nature". Там той отбелязва  "облаците не са сфери, планините не са конуси, бреговите линии не са  окръжности, кората на дърветата не е гладка, нито светлината се движи по права  линия". През 70-те години Манделброт опитва да сближи формите на математиката с  тези на природата, като предлага нов тип математически форми, способни да  опишат структурната нерегулярност на естествения свят. Той дава име на въведените  нови геометрични форми - фрактали. Терминът фрактал идва да подскаже, че  обектът фрактал показва определена структура върху голям обхват от мащаби. <br />
			    Дефиниция: Фрактал  е геометричен обект, който има свойството всяка негова част при мащабиране да възпроизвежда  структурата на оригиналния обект. <br />
			    Добър пример за естествено срещан фрактал е бреговата линия.  Карта на брегова линия показва характерни особености като наличие на заливи и  полуострови. Мащабирането на част от бреговата линия показва в по-големи  детайли същите особености - заливи и полуострови. Мащабирането на част от тази  част също показва тези особености. <br />
			    Една математическа крива със същото свойство е така  наречената "снежинка" на Хелга фон Кох. Правилото за генерирането й е следното:  началната фигура е един равностранен триъгълник, всяка страна на който е  разделена на три равни части. Върху средната отсечка на всяка страна се  построява равностранен триъгълник със страна - една трета от тази на  оригиналния. За получените шест триъгълника се прилага същото правило и т.н. </p>
			  <br clear="all" />
              <div>
                <div>
                  <table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="56">
                    <tr>
                      <td valign="top" align="left" height="56"><p><img width="120" height="56" src="images/recursion_image012.jpg" alt="123" /> </p></td>
                    </tr>
                  </table>
                </div>
                <div>
                  <table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="56">
                    <tr>
                      <td valign="top" align="left" height="56"><p align="center"><img width="121" height="56" src="images/recursion_image014.jpg" alt="143" /> </p></td>
                    </tr>
                  </table>
                </div>
                <p>Фиг.  1. Снежинката на Х.фон Кох </p>
                <p>Фактът, че всяка частица от фрактала се генерира по едно  и също правило, води към това, че алгоритъмът за построяването му ще бъде  рекурсивен. <br />
                  Един  леко осъществим пример <br />
                  Нека приемем, че имаме процедура draw(x,y,r,bg), която  чертае квадрат с център в точка с координати (х,у),  със страна 2г и запълва квадрата с фон bg, като например bg = 1  означава боядисване на квадрата с бяло, a bg = 0 - съответно с черно. Правилото за генериране на фрактала  е: във всеки връх на оригиналния квадрат се генерира нова фигура с център  съответния връх, страна два пъти по- малка от предходната и се боядисва с  противния фон. </p>
                <div>
                  <table cellspacing="0" cellpadding="0" hspace="0" vspace="0" height="111">
                    <tr>
                      <td valign="top" align="left" height="111"><br />
                      <img width="156" height="166" src="images/recursion_image016.jpg" alt="163" /> </td>
                    </tr>
                  </table>
                </div>
                <p>Така  алгоритъмът за генериране на този прост фрактал ще изглежда по този начин: <br />
                  алгоритъм fractal(x,y,r,bg); <br />
                  ако r &gt; rmin то <br />
                  draw(x,y,r,bg); <br />
                  fractal(x-r,y-r,r div 2,1-bg); <br />
                  fractal(x - r, y+r, r div 2,1- bg); <br />
                  fractal(x+r,y-r,r div 2,1- bg);<br />
                  fractal(x+r,y+r,r div 2,1- bg);<br />
                  Обръщението към този  алгоритъм ще бъде <br />
                  fractal  (х0,у0,r0,1); <br />
                  като  трябва правилно да се определят параметрите х0,у0,r0.  Ако <em>х</em>mах  и уmах  с съответно максималните възможни дължини по осите х и у  върху екрана, тo  фракталът трябва да се събере в квадрат със страна d = min(xmax,ymax).  Тъй катo  четвъртинка от фигурата се простира в квадрат със страна <br />
                  <img src="images/recursion_image018.gif" alt="183" width="14" height="19" />=<img src="images/recursion_image020.gif" alt="203" width="235" height="29" /> <br />
                  то <img src="images/recursion_image018_0000.gif" alt="1803" width="14" height="19" />  трябва да е<br />
                  <img src="images/recursion_image022.gif" alt="223" width="44" height="36" /> </p>
                <p>От друга страна, за  да имаме на всяко ниво на рекурсия страна на квадрата цяло число, то r0 трябва да е степен на двойката: r0=2к. Следователно к е най-голямото цяло, за което 2k&#8804;<img src="images/recursion_image024.gif" alt="243" width="8" height="14" /> . Координатите x0 и y0 са <img src="images/recursion_image026.gif" alt="263" width="81" height="14" /> . Аналогично трябва да се определи и подходяща стойност на  параметъра rmin,който отделя тривиалния случай (неявно) от общия в  рекурсивния алгоритъм fractal.</p>
              </div>
              <h1 align="center"><br />
			  </h1>
	  </div>
	   <a style="display:scroll;position:fixed;bottom:10px;right:10px;" href="#" title="В началото"><img width="30" height="30" src="images/button.png"/></a>  
</div>
	
<div id="footer">
			<p>&copy; Copyright Synthesis and Analysis of Algorithms &middot; 2017 &middot; Design: Elitsa Nikolova&middot; 
			 
			  <a href="index.html"><span>Алгоритми</span></a>&middot;
              <a href="struct.html"><span>Структури данни</span></a>&middot;
               <a href="metods.html"><span>Методи за създаване</span></a>&middot;
               <a href="sort.html"><span>Алгоритми за сортиране</span></a>&middot;
		    <a href="map.html"><span>Карта на сайта</span></a></p>
</div>
</body>
</html>